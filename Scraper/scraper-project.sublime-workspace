{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"scrap",
				"scrapeLimit"
			],
			[
				"clean",
				"cleanedPath"
			],
			[
				"currend",
				"currentDateNumRings"
			],
			[
				"current",
				"currentDate"
			],
			[
				"ouput",
				"outputLocation"
			],
			[
				"curre",
				"currentDateNumRings"
			],
			[
				"currentD",
				"currentDate"
			],
			[
				"Off",
				"OFFLINE"
			],
			[
				"assign",
				"assignedRingsCurrentDate"
			],
			[
				"currentDate",
				"currentDateIndex"
			],
			[
				"curr",
				"currentDate"
			],
			[
				"assig",
				"assignedRingsCurrentDate"
			],
			[
				"curren",
				"currentDateIndex"
			],
			[
				"showDeta",
				"showDetailList"
			],
			[
				"showDet",
				"showDetailList"
			],
			[
				"date",
				"datemap"
			],
			[
				"NE",
				"nextDate"
			],
			[
				"Date",
				"DATE"
			],
			[
				"Rege",
				"RegexPatternDef"
			],
			[
				"Reg",
				"RegexPatternDef"
			],
			[
				"Ring",
				"RINGS_AND_DATES"
			],
			[
				"RING",
				"RINGS_AND_DATES"
			],
			[
				"REG",
				"RegexPatternDef"
			],
			[
				"loc",
				"locationList"
			],
			[
				"location",
				"locationsList"
			],
			[
				"post",
				"postShow"
			],
			[
				"uni",
				"uniqueShowList"
			],
			[
				"AppS",
				"AppServerAccessor"
			],
			[
				"_pdf",
				"_pdfPath"
			],
			[
				"pdf",
				"pdfFilePath"
			],
			[
				"program",
				"programName"
			],
			[
				"par",
				"parsedPath"
			],
			[
				"output",
				"outputLocation"
			],
			[
				"file",
				"filename"
			],
			[
				"do",
				"downloadPrograms"
			],
			[
				"postS",
				"postShows"
			],
			[
				"progra",
				"programName"
			],
			[
				"_get",
				"_getUniqueShows"
			],
			[
				"Show",
				"ShowScraper"
			],
			[
				"url",
				"urlopen_with_retry"
			],
			[
				"pullShow",
				"pullShowsFromOnofrio"
			],
			[
				"pull",
				"pullShowsFromOnofrio"
			],
			[
				"close",
				"closedShowsPage"
			],
			[
				"_",
				"_pagelink"
			],
			[
				"prog",
				"programName"
			],
			[
				"base",
				"baseUrl"
			],
			[
				"bas",
				"baseJP"
			],
			[
				"parse",
				"parseShowPage"
			],
			[
				"find",
				"findStartDate"
			],
			[
				"_p",
				"_pagelink"
			],
			[
				"fin",
				"findStartDate"
			],
			[
				"pu",
				"pullShowCode"
			],
			[
				"an",
				"anchor"
			],
			[
				"ancho",
				"anchor"
			],
			[
				"anc",
				"anchors"
			],
			[
				"minim",
				"Minimum"
			],
			[
				"print",
				"printRecord"
			],
			[
				"suppor",
				"supportsIndexing"
			],
			[
				"random",
				"randomWPs"
			],
			[
				"wpre",
				"WPRecord"
			],
			[
				"WPRe",
				"WPRecord"
			],
			[
				"noPel",
				"noPelletsMap"
			],
			[
				"noP",
				"noPelletsMap"
			],
			[
				"checkPe",
				"checkPellets"
			],
			[
				"Pellet",
				"PelletTopRow"
			],
			[
				"cout",
				"countAll"
			],
			[
				"check",
				"checkInnerBorders"
			],
			[
				"pacm",
				"pacmanToGhost"
			],
			[
				"removeGhost",
				"removeGhostFromMap"
			],
			[
				"rep",
				"replaceElement"
			],
			[
				"checkH",
				"checkHelp"
			],
			[
				"NewGhost",
				"NewGhostType"
			],
			[
				"NewGho",
				"NewGhostType"
			],
			[
				"ghost",
				"ghostReplacement"
			],
			[
				"stat",
				"statsTable"
			],
			[
				"moveG",
				"moveGhostSet"
			],
			[
				"ghos",
				"ghostLocations"
			],
			[
				"tupl",
				"tupleFourth"
			],
			[
				"moveGhost",
				"moveGhosts"
			],
			[
				"valid",
				"validCoords"
			],
			[
				"tuple",
				"tupleSecond"
			],
			[
				"start",
				"startCol"
			],
			[
				"seco",
				"second"
			],
			[
				"pac",
				"pacmanLocation"
			],
			[
				"place",
				"placeElementInMatrix"
			],
			[
				"secon",
				"secondIn3"
			],
			[
				"first",
				"firstIn3"
			],
			[
				"target",
				"targetRow"
			],
			[
				"min",
				"minDistance"
			],
			[
				"vali",
				"validCoords"
			],
			[
				"level",
				"levelUp"
			],
			[
				"DRRRR",
				"DRRRRURRRDD"
			],
			[
				"minus",
				"minusCorners"
			],
			[
				"rese",
				"resetPowerPellets"
			],
			[
				"sub",
				"subMiddleNthMatrixRow"
			],
			[
				"replace",
				"replaceNthElement"
			],
			[
				"sum",
				"subMiddleList"
			],
			[
				"subMiddle",
				"subMiddleMatrixRow"
			],
			[
				"subMid",
				"subMiddleMatrix"
			],
			[
				"re",
				"moveAndReplaceElement"
			],
			[
				"elem",
				"elementAtCoords"
			],
			[
				"eleme",
				"elementAt"
			],
			[
				"Int",
				"Int"
			]
		]
	},
	"buffers":
	[
		{
			"file": "dogshowprogramworker.py",
			"settings":
			{
				"buffer_size": 9919,
				"line_ending": "Windows"
			}
		},
		{
			"contents": "Searching 75 files for \"lines after \" (regex)\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\ringcleaner.py:\n   75  		lineArr = str(text).split('\\n');\n   76  \n   77: 		print(str(len(lineArr)) + \" lines after split\");\n   78  		dateRingList = [line for line in lineArr if re.match(RegexPatternDef.DATE, line) or re.match(\"RING \\d+\", line)]\n   79  		print(len(dateRingList));\n\n1 match in 1 file\n\n\nSearching 75 files for \"cleanPdf2Txt\" (regex)\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\ringcleaner.py:\n   29  		#print(string['Rings']);\n   30  	\n   31: 	def cleanPdf2Txt(self, pdfPath):\n   32  		cleanedPath = config.Grammar.CLEANED_PROGRAM_DIR + os.path.basename(pdfPath)\n   33  		if not os.path.isfile(cleanedPath):\n   ..\n   45  	def collectRingDates(self, filePath):\n   46  		parsedFilePath = self._runner.parseProgramPdf2Txt(filePath)\n   47: 		cleanedPath = self.cleanPdf2Txt(parsedFilePath)\n   48  		text = None;\n   49  		with codecs.open (cleanedPath, \"r\", 'UTF-8') as outputFile:\n\n2 matches in 1 file\n\n\nSearching 75 files for \"after split\" (regex)\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\ringcleaner.py:\n   75  		lineArr = str(text).split('\\n');\n   76  \n   77: 		print(str(len(lineArr)) + \" lines after split\");\n   78  		dateRingList = [line for line in lineArr if re.match(RegexPatternDef.DATE, line) or re.match(\"RING \\d+\", line)]\n   79  		print(len(dateRingList));\n\n1 match in 1 file\n\n\nSearching 75 files for \"collected show JSON\" (regex)\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\dogshowprogramworker.py:\n   74          if pdfPath:\n   75              showJson = self.getShowJson(pdfPath);\n   76:             print(str(\"collected show JSON: \") + str(showJson is not None))\n   77              if 'Rings' not in showJson:\n   78                  print(\"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\")\n\n1 match in 1 file\n\n\nSearching 75 files for \"reading from file\" (regex)\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\parserunner.py:\n   45                  proc = subprocess.Popen(['python27', './libs/pdfminer-20110515/tools/pdf2txt.py', fullPdfPath],  stdout=open(outputLocation, \"w\"))\n   46              else:\n   47:                 print(\"Already exists: \" + outputLocation + \"; reading from file.\");\n   48              #with codecs.open (outputLocation, \"r\", 'UTF-8') as outputFile:\n   49              #    text = outputFile.read();\n\n1 match in 1 file\n\n\nSearching 75 files for \"parseProgramPdf2Txt\" (regex)\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\parserunner.py:\n   37      Returns: the parsed text\n   38      \"\"\"\n   39:     def parseProgramPdf2Txt(self, fullPdfPath):\n   40          if fullPdfPath is not None:\n   41              output = os.path.basename(fullPdfPath)[:-3] + \"pdf2txt.txt\"\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\ringcleaner.py:\n   45  	\"\"\"\n   46  	def collectRingDates(self, filePath):\n   47: 		parsedFilePath = self._runner.parseProgramPdf2Txt(filePath)\n   48  		cleanedPath = self.cleanPdf2Txt(parsedFilePath)\n   49  		text = None;\n\n2 matches across 2 files\n\n\nSearching 75 files for \"setting pdf\" (regex)\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\dogshowprogramworker.py:\n  179      \"\"\"\n  180      def downloadProgram(self, show):\n  181:         print(\"setting pdf path...\")\n  182          pdfPath = config.Pdf.DOWNLOAD_DIR+show.code+\".pdf\";\n  183          print(\"pdf path is \" + pdfPath)\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\show.py:\n   81  \n   82      def downloadProgram(self):\n   83:         print(\"setting pdf path...\")\n   84          self._pdfPath = config.Pdf.DOWNLOAD_DIR+self.programName\n   85          print(\"pdf path is \" + self._pdfPath)\n\n2 matches across 2 files\n\n\nSearching 75 files for \"did not download\" (regex)\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\dogshowprogramworker.py:\n  197              return pdfPath;\n  198          else:\n  199:             print(\"Did not download program!\")\n  200              print(\"Does it exist? \" + str(os.path.isfile(pdfPath)))\n  201              if os.path.isfile(pdfPath):\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\show.py:\n  101              return True;\n  102          else:\n  103:             print(\"Did not download program!\")\n  104              return False; \n\n2 matches across 2 files\n\n\nSearching 75 files for \".code\" (regex)\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\appserver_accessor.py:\n   12          response = urlopen_with_retry(url, values)\n   13  \n   14:         #response = urlopen_with_retry(url, data.encode('utf8'))\n   15          the_page = response.read()\n   16          pass;\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\demo.py:\n   22      data = None\n   23      if values is not None:\n   24:         data = urllib.parse.urlencode(values)\n   25:         data = data.encode('utf-8') # data should be bytes\n   26      req = urllib.request.Request(url, data)\n   27      return urllib.request.urlopen(req)\n   ..\n   35      response = urlopen_with_retry(url, values)\n   36  \n   37:     #response = urlopen_with_retry(url, data.encode('utf8'))\n   38      the_page = response.read()\n   39      print(\"response page: \" + str(the_page))\n   ..\n   42  class Show(object):\n   43      \n   44:     def __init__(self, club, pageLink, programcode):\n   45          self._club = club;\n   46          self._pagelink = pageLink;\n   47:         self._programcode = programcode;\n   48          self._location = None;\n   49          self._date = None;\n   ..\n   60              + \"\\n\\t\"  + self._location \n   61              + \"\\n\\t\" + \"page link:\" + self._pagelink \n   62:             + \"\\n\\t program code: \" + self._programcode);\n   63  \n   64      @property\n   ..\n  128                  print(\"download died: \" + self._pagelink)\n  129                  return False;\n  130:             #self._programcode = \"PPTO1\";\n  131              pdfName = self.programName; \n  132              url = baseUrl + self._pdfLink;\n  ...\n  157          return str(match.group());\n  158  \n  159: def pullShowCode(link):\n  160:     codePattern = \"=(?P<link>[a-zA-Z]+[0-9])\";\n  161:     match = re.search(codePattern, link);\n  162      if match:\n  163          return str(match.group('link'));\n  ...\n  169  def pullShowsFromOnofrio():\n  170      values = {'s' : sys.argv[0] }\n  171:     data = urllib.parse.urlencode(values)\n  172      global closedShowsPage\n  173      if OFFLINE:\n  ...\n  183          link = anchor['href']\n  184          club = pullKennelClub(anchor);\n  185:         code = pullShowCode(link)\n  186:         if club and code:\n  187:             show = Show(club, baseUrl+link, code)\n  188              shows.append(show)\n  189              #print(show);\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\dogshowprogramworker.py:\n  154          url = config.AppServer.SHOW_POST_URL\n  155          \n  156:         values = show.toJson();#{'id':show.code, 'clubs':str(show.clubs), 'locations':str(locations) 'date':int(show.dates[0])}\n  157          locationList = list();\n  158          [locationList.append(l.toJson()) for l in show.locations];\n  ...\n  160          print(show.getDateList())\n  161          print(str(values));\n  162:         values = {'code':show.code, 'locations':json.loads(json.dumps(locationList)), 'clubs':show.getClubList(), 'show':values, 'dates':show.getDateList()}\n  163          #values = {'city': 'Columbiana', 'date': 1365138000.0, 'name': 'Northeast Oklahoma Kennel Club', 'state': 'AL'}\n  164          response = urlopen_with_retry(url, values)\n  165  \n  166:         #response = urlopen_with_retry(url, data.encode('utf8'))\n  167          the_page = response.read()\n  168          print(the_page);\n  ...\n  170      def downloadPrograms(self, shows):\n  171          for show in shows:\n  172:             print(\"Show code: \" + show.code)\n  173              show.downloadProgram()\n  174          return shows\n  ...\n  180      def downloadProgram(self, show):\n  181          print(\"setting pdf path...\")\n  182:         pdfPath = config.Pdf.DOWNLOAD_DIR+show.code+\".pdf\";\n  183          print(\"pdf path is \" + pdfPath)\n  184          if not config.Env.OFFLINE and config.Env.DO_DOWNLOAD:\n  ...\n  186                  print(\"Skipping... file already downloaded\");\n  187                  return pdfPath;\n  188:             pdfName = show.code;         \n  189              print(\"*** Downloading ***\" + config.Onofrio.pdfUrl(show.pdfLink));\n  190              (filename, headers) = urllib.request.urlretrieve(config.Onofrio.pdfUrl(show.pdfLink),pdfPath)\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\driver.py:\n   15      url = config.AppServer.SHOW_POST_URL\n   16      \n   17:     values = show.toJson();#{'id':show.code, 'clubs':str(show.clubs), 'locations':str(locations) 'date':int(show.dates[0])}\n   18      locationList = list();\n   19      [locationList.append(l.toJson()) for l in show.locations];\n   ..\n   21      print(show.getDateList())\n   22      print(str(values));\n   23:     values = {'code':show.code, 'locations':json.loads(json.dumps(locationList)), 'clubs':show.getClubList(), 'show':values, 'dates':show.getDateList()}\n   24      #values = {'city': 'Columbiana', 'date': 1365138000.0, 'name': 'Northeast Oklahoma Kennel Club', 'state': 'AL'}\n   25      response = urlopen_with_retry(url, values)\n   26  \n   27:     #response = urlopen_with_retry(url, data.encode('utf8'))\n   28      the_page = response.read()\n   29      print(the_page);\n   ..\n   35  def downloadPrograms(shows):\n   36      for show in shows:\n   37:         print(\"Show code: \" + show.code)\n   38          show.downloadProgram()\n   39      return shows\n   ..\n  146              doParseAndClean(show);\n  147              print(\"programName: \" + show.programName)\n  148:             if show.showCode == \"KTDC1\":\n  149                  print(\"found KTDC1\")\n  150                  json = doRunGrammar(show);\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\parserunner.py:\n    3  import subprocess\n    4  from util import RegexHelper\n    5: import codecs\n    6  \n    7  class ParseRunner(object):\n    .\n   46              else:\n   47                  print(\"Already exists: \" + outputLocation + \"; reading from file.\");\n   48:             #with codecs.open (outputLocation, \"r\", 'UTF-8') as outputFile:\n   49              #    text = outputFile.read();\n   50              #    return text;\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\ringcleaner.py:\n    8  import os\n    9  from collections import OrderedDict\n   10: import codecs\n   11  import sys\n   12  import subprocess\n   ..\n   48  		cleanedPath = self.cleanPdf2Txt(parsedFilePath)\n   49  		text = None;\n   50: 		with codecs.open (cleanedPath, \"r\", 'UTF-8') as outputFile:\n   51  			text = outputFile.read();\n   52  		dateRingMap = self._getDateRingMap(text);\n   ..\n   71  	def _getDateRingMap(self, text):\n   72  		#Default encoding can't handle bullets etc. in file\n   73: 		text = text.encode('utf-8')\n   74  		text = str(text);\n   75  		text = text.replace('\\\\r\\\\n','\\n').replace('\\\\r','\\n').replace('\\\\n','\\n');\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\show.py:\n   14      DO_DOWNLOAD = True;\n   15      \n   16:     def __init__(self, club, pageLink, programcode):\n   17          self._club = club;\n   18          self._pagelink = pageLink;\n   19:         self._programcode = programcode;\n   20          self._location = None;\n   21          self._date = None;\n   ..\n   36              + \"\\n\\t\"  + str(self._location) \n   37              + \"\\n\\t\" + \"page link:\" + str(self._pagelink) \n   38:             + \"\\n\\t program code: \" + str(self._programcode)\n   39              + \"\\n\\t program file name: \" + str(self.programName)\n   40              + \"\\n\\t PDF Path: \" + str(self._pdfPath) + ' or ' + str(self.pdfFilePath)  );\n   ..\n   45  \n   46      @property\n   47:     def showCode(self):\n   48:         return self._programcode;\n   49  \n   50      @parsedFilePath.setter\n   ..\n   88                  print(\"download died: \" + self._pagelink)\n   89                  return False;\n   90:             #self._programcode = \"PPTO1\";\n   91              pdfName = self.programName; \n   92              url = config.Onofrio.pdfUrl(self._pdfLink)            \n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\showscraper.py:\n   48              location = self._parseLocation(pool);\n   49              #self._hasProgram = self._checkIfProgram(pool);\n   50:             code = self._pullShowCode(pool);\n   51              if self.VERBOSE:\n   52:                 print('code:' + str(code));\n   53              pdfLink = self._pullPdfLink(pool);\n   54              if self.VERBOSE:\n   55                  print('pdf link: ' + str(pdfLink));\n   56:             show = Show(code, club, location, date);\n   57              show.pdfLink = pdfLink;\n   58              print(\"************************************\")\n   ..\n  154          #return ScrapeHelper.pullAnchorText(link, RegexHelper.getPattern(RegexPattern.KENNEL_CLUB));\n  155  \n  156:     def _pullShowCode(self, pool):\n  157:         #print(\"_pullShowCode not implemented\")\n  158          #sys.exit(1);\n  159          notAvailable = pool.findAll(text=\"Judging Program Not Available\");\n  ...\n  161              results = pool.findAll('a', href=True, text='Judging Program (PDF Format)');\n  162              if results:\n  163:                 print('_pullShowCode found the program anchor');\n  164                  self.pdfLink = results[0]['href'];\n  165:                 code = re.search(\"(?P<name>(?P<code>[A-Z]+[0-9])\\JP.pdf)\", self.pdfLink).group('code')\n  166:                 return code;\n  167              else:\n  168                  print(\"died: \" + str(results) + \" \" + self._pagelink)\n  169                  return None;\n  170          else:\n  171:             print('show code not available')\n  172              None;\n  173  \n  174      def _pullPdfLink(self, pool):\n  175:         #print(\"_pullShowCode not implemented\")\n  176          #sys.exit(1);\n  177          notAvailable = pool.findAll(text=\"Judging Program Not Available\");\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\showutils.py:\n   10      if values is not None:\n   11          print(\"POST REQUEST to \" + url)\n   12:         data = urllib.parse.urlencode(values)\n   13:         data = data.encode('utf-8') # data should be bytes\n   14      else:\n   15          time.sleep(2);\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\util.py:\n    6  class RegexPattern(object):\n    7  	KENNEL_CLUB = \"kennel_club\";\n    8: 	SHOW_CODE   = \"show_code\";\n    9  	LOCATION_DATE = \"location_date\";\n   10  \n   11  class RegexPatternDef(object):\n   12  	KENNEL_CLUB = \"([a-zA-Z-]+(?: [a-zA-Z-,]+)*)\";\n   13: 	SHOW_CODE = \"=(?P<link>[a-zA-Z]+[0-9])\";\n   14  	WEEK_DAY = \"(?:Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday)\";\n   15  	MONTH = \"(?:January|February|March|April|May|June|July|August|September|October|November|December)\";\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\build\\lib\\pdfminer\\arcfour.py:\n    3  \"\"\" Python implementation of Arcfour encryption algorithm.\n    4  \n    5: This code is in the public domain.\n    6  \n    7  \"\"\"\n    .\n   12  \n   13      \"\"\"\n   14:     >>> Arcfour('Key').process('Plaintext').encode('hex')\n   15      'bbf316e8d940af0ad3'\n   16:     >>> Arcfour('Wiki').process('pedia').encode('hex')\n   17      '1021bf0420'\n   18:     >>> Arcfour('Secret').process('Attack at dawn').encode('hex')\n   19      '45a01f645fc35b383552544b9bf5'\n   20      \"\"\"\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\build\\lib\\pdfminer\\ascii85.py:\n    1  #!/usr/bin/env python2\n    2  \n    3: \"\"\" Python implementation of ASCII85/ASCIIHex decoder (Adobe version).\n    4  \n    5: This code is in the public domain.\n    6  \n    7  \"\"\"\n    .\n   10  import struct\n   11  \n   12: # ascii85decode(data)\n   13: def ascii85decode(data):\n   14      \"\"\"\n   15:     In ASCII85 encoding, every four bytes are encoded with five ASCII\n   16      letters, using 85 different types of characters (as 256**4 < 85**5).\n   17      When the length of the original bytes is not a multiple of 4, a special\n   ..\n   24        http://en.wikipedia.org/w/index.php?title=Ascii85\n   25      \n   26:     >>> ascii85decode('9jqo^BlbD-BleB1DJ+*+F(f,q')\n   27      'Man is distinguished'\n   28:     >>> ascii85decode('E,9)oF*2M7/c~>')\n   29      'pleasure.'\n   30      \"\"\"\n   ..\n   49      return out\n   50  \n   51: # asciihexdecode(data)\n   52  hex_re = re.compile(r'([a-f\\d]{2})', re.IGNORECASE)\n   53  trail_re = re.compile(r'^(?:[a-f\\d]{2}|\\s)*([a-f\\d])[\\s>]*$', re.IGNORECASE)\n   54: def asciihexdecode(data):\n   55      \"\"\"\n   56:     ASCIIHexDecode filter: PDFReference v1.4 section 3.3.1\n   57      For each pair of ASCII hexadecimal digits (0-9 and A-F or a-f), the\n   58:     ASCIIHexDecode filter produces one byte of binary data. All white-space\n   59      characters are ignored. A right angle bracket character (>) indicates\n   60      EOD. Any other characters will cause an error. If the filter encounters\n   ..\n   62      will behave as if a 0 followed the last digit.\n   63      \n   64:     >>> asciihexdecode('61 62 2e6364   65')\n   65      'ab.cde'\n   66:     >>> asciihexdecode('61 62 2e6364   657>')\n   67      'ab.cdep'\n   68:     >>> asciihexdecode('7>')\n   69      'p'\n   70      \"\"\"\n   71:     decode = (lambda hx: chr(int(hx, 16)))\n   72:     out = map(decode, hex_re.findall(data))\n   73      m = trail_re.search(data)\n   74      if m:\n   75:         out.append(decode(\"%c0\" % m.group(1)))\n   76      return ''.join(out)\n   77  \n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\build\\lib\\pdfminer\\cmapdb.py:\n    3  \"\"\" Adobe character mapping (CMap) support.\n    4  \n    5: CMaps provide the mapping between character codes and Unicode\n    6  code-points to character ids (CIDs).\n    7  \n    .\n   24  from psparser import PSLiteral, PSKeyword\n   25  from psparser import literal_name, keyword_name\n   26: from encodingdb import name2unicode\n   27  from utils import choplist, nunpack\n   28  \n   ..\n   37      debug = 0\n   38  \n   39:     def __init__(self, code2cid=None):\n   40:         self.code2cid = code2cid or {}\n   41          return\n   42  \n   ..\n   54                  else:\n   55                      dst[k] = v\n   56:         copy(self.code2cid, cmap.code2cid)\n   57          return\n   58  \n   59:     def decode(self, code):\n   60          if self.debug:\n   61:             print >>sys.stderr, 'decode: %r, %r' % (self, code)\n   62:         d = self.code2cid\n   63:         for c in code:\n   64              c = ord(c)\n   65              if c in d:\n   ..\n   67                  if isinstance(d, int):\n   68                      yield d\n   69:                     d = self.code2cid\n   70              else:\n   71:                 d = self.code2cid\n   72          return\n   73  \n   74:     def dump(self, out=sys.stdout, code2cid=None, code=None):\n   75:         if code2cid is None:\n   76:             code2cid = self.code2cid\n   77:             code = ()\n   78:         for (k,v) in sorted(code2cid.iteritems()):\n   79:             c = code+(k,)\n   80              if isinstance(v, int):\n   81:                 out.write('code %r = cid %d\\n' % (c,v))\n   82              else:\n   83:                 self.dump(out=out, code2cid=v, code=c)\n   84          return\n   85      \n   ..\n   96          return self.vertical\n   97  \n   98:     def decode(self, code):\n   99:         n = len(code)/2\n  100          if n:\n  101:             return struct.unpack('>%dH' % n, code)\n  102          else:\n  103              return ()\n  ...\n  105              \n  106  \n  107: ##  UnicodeMap\n  108  ##\n  109: class UnicodeMap(object):\n  110  \n  111      debug = 0\n  ...\n  122      def dump(self, out=sys.stdout):\n  123          for (k,v) in sorted(self.cid2unichr.iteritems()):\n  124:             out.write('cid %d = unicode %r\\n' % (k,v))\n  125          return\n  126  \n  ...\n  145          return\n  146  \n  147:     def add_code2cid(self, code, cid):\n  148:         assert isinstance(code, str) and isinstance(cid, int)\n  149:         d = self.code2cid\n  150:         for c in code[:-1]:\n  151              c = ord(c)\n  152              if c in d:\n  ...\n  156                  d[c] = t\n  157                  d =t\n  158:         c = ord(code[-1])\n  159          d[c] = cid\n  160          return\n  161  \n  162  \n  163: ##  FileUnicodeMap\n  164  ##\n  165: class FileUnicodeMap(UnicodeMap):\n  166      \n  167      def __init__(self):\n  168:         UnicodeMap.__init__(self)\n  169          self.attrs = {}\n  170          return\n  171  \n  172      def __repr__(self):\n  173:         return '<UnicodeMap: %s>' % self.attrs.get('CMapName')\n  174  \n  175      def set_attr(self, k, v):\n  ...\n  177          return\n  178  \n  179:     def add_cid2unichr(self, cid, code):\n  180          assert isinstance(cid, int)\n  181:         if isinstance(code, PSLiteral):\n  182              # Interpret as an Adobe glyph name.\n  183:             self.cid2unichr[cid] = name2unicode(code.name)\n  184:         elif isinstance(code, str):\n  185              # Interpret as UTF-16BE.\n  186:             self.cid2unichr[cid] = unicode(code, 'UTF-16BE', 'ignore')\n  187:         elif isinstance(code, int):\n  188:             self.cid2unichr[cid] = unichr(code)\n  189          else:\n  190:             raise TypeError(code)\n  191          return\n  192  \n  ...\n  197  \n  198      def __init__(self, name, module):\n  199:         CMap.__init__(self, module.CODE2CID)\n  200          self.name = name\n  201          self._is_vertical = module.IS_VERTICAL\n  ...\n  209      \n  210  \n  211: ##  PyUnicodeMap\n  212  ##\n  213: class PyUnicodeMap(UnicodeMap):\n  214      \n  215      def __init__(self, name, module, vertical):\n  ...\n  218          else:\n  219              cid2unichr = module.CID2UNICHR_H\n  220:         UnicodeMap.__init__(self, cid2unichr)\n  221          self.name = name\n  222          return\n  223  \n  224      def __repr__(self):\n  225:         return '<PyUnicodeMap: %s>' % (self.name)\n  226  \n  227  \n  ...\n  268  \n  269      @classmethod\n  270:     def get_unicode_map(klass, name, vertical=False):\n  271          try:\n  272              return klass._umap_cache[name][vertical]\n  273          except KeyError:\n  274              pass\n  275:         data = klass._load_data('to-unicode-%s' % name)\n  276:         klass._umap_cache[name] = umaps = [PyUnicodeMap(name, data, v) for v in (False, True)]\n  277          return umaps[vertical]\n  278  \n  ...\n  324              return\n  325  \n  326:         if name == 'begincodespacerange':\n  327              self.popall()\n  328              return\n  329:         if name == 'endcodespacerange':\n  330              self.popall()\n  331              return\n  ...\n  350                  for i in xrange(e1-s1+1):\n  351                      x = sprefix+struct.pack('>L',s1+i)[-vlen:]\n  352:                     self.cmap.add_code2cid(x, cid+i)\n  353              return\n  354  \n  ...\n  358          if name == 'endcidchar':\n  359              objs = [ obj for (_,obj) in self.popall() ]\n  360:             for (cid,code) in choplist(2, objs):\n  361:                 if isinstance(code, str) and isinstance(cid, str):\n  362:                     self.cmap.add_code2cid(code, nunpack(cid))\n  363              return\n  364  \n  ...\n  368          if name == 'endbfrange':\n  369              objs = [ obj for (_,obj) in self.popall() ]\n  370:             for (s,e,code) in choplist(3, objs):\n  371                  if (not isinstance(s, str) or not isinstance(e, str) or\n  372                      len(s) != len(e)): continue\n  ...\n  374                  e1 = nunpack(e)\n  375                  #assert s1 <= e1\n  376:                 if isinstance(code, list):\n  377                      for i in xrange(e1-s1+1):\n  378:                         self.cmap.add_cid2unichr(s1+i, code[i])\n  379                  else:\n  380:                     var = code[-4:]\n  381                      base = nunpack(var)\n  382:                     prefix = code[:-4]\n  383                      vlen = len(var)\n  384                      for i in xrange(e1-s1+1):\n  ...\n  392          if name == 'endbfchar':\n  393              objs = [ obj for (_,obj) in self.popall() ]\n  394:             for (cid,code) in choplist(2, objs):\n  395:                 if isinstance(cid, str) and isinstance(code, str):\n  396:                     self.cmap.add_cid2unichr(nunpack(cid), code)\n  397              return\n  398  \n  ...\n  412      for fname in args:\n  413          fp = file(fname, 'rb')\n  414:         cmap = FileUnicodeMap()\n  415          #cmap = FileCMap()\n  416          CMapParser(cmap, fp).run()\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\build\\lib\\pdfminer\\converter.py:\n    2  import sys, os.path\n    3  from pdfdevice import PDFDevice, PDFTextDevice\n    4: from pdffont import PDFUnicodeNotDefined\n    5: from pdftypes import LITERALS_DCT_DECODE\n    6  from pdfcolor import LITERAL_DEVICE_GRAY, LITERAL_DEVICE_RGB\n    7  from layout import LTContainer, LTPage, LTText, LTLine, LTRect, LTCurve\n    .\n   96          try:\n   97              text = font.to_unichr(cid)\n   98:             assert isinstance(text, unicode), text\n   99:         except PDFUnicodeNotDefined:\n  100              text = self.handle_undefined_char(font, cid)\n  101          textwidth = font.char_width(cid)\n  ...\n  135  class PDFConverter(PDFLayoutAnalyzer):\n  136  \n  137:     def __init__(self, rsrcmgr, outfp, codec='utf-8', pageno=1, laparams=None):\n  138          PDFLayoutAnalyzer.__init__(self, rsrcmgr, pageno=pageno, laparams=laparams)\n  139          self.outfp = outfp\n  140:         self.codec = codec\n  141          return\n  142  \n  ...\n  144          stream = image.stream\n  145          filters = stream.get_filters()\n  146:         if len(filters) == 1 and filters[0] in LITERALS_DCT_DECODE:\n  147              ext = '.jpg'\n  148              data = stream.get_rawdata()\n  ...\n  168  class TextConverter(PDFConverter):\n  169  \n  170:     def __init__(self, rsrcmgr, outfp, codec='utf-8', pageno=1, laparams=None,\n  171                   showpageno=False):\n  172:         PDFConverter.__init__(self, rsrcmgr, outfp, codec=codec, pageno=pageno, laparams=laparams)\n  173          self.showpageno = showpageno\n  174          return\n  175  \n  176      def write_text(self, text):\n  177:         self.outfp.write(text.encode(self.codec, 'ignore'))\n  178          return\n  179  \n  ...\n  221          }\n  222  \n  223:     def __init__(self, rsrcmgr, outfp, codec='utf-8', pageno=1, laparams=None, \n  224                   scale=1, fontscale=0.7, layoutmode='normal', showpageno=True,\n  225                   pagemargin=50, outdir=None,\n  226                   rect_colors={'curve':'black', 'page':'gray'},\n  227                   text_colors={'char':'black'}):\n  228:         PDFConverter.__init__(self, rsrcmgr, outfp, codec=codec, pageno=pageno, laparams=laparams)\n  229          self.scale = scale\n  230          self.fontscale = fontscale\n  ...\n  250      def write_header(self):\n  251          self.write('<html><head>\\n')\n  252:         self.write('<meta http-equiv=\"Content-Type\" content=\"text/html; charset=%s\">\\n' % self.codec)\n  253          self.write('</head><body>\\n')\n  254          return\n  ...\n  261  \n  262      def write_text(self, text):\n  263:         self.write(enc(text, self.codec))\n  264          return\n  265  \n  ...\n  401  class XMLConverter(PDFConverter):\n  402  \n  403:     def __init__(self, rsrcmgr, outfp, codec='utf-8', pageno=1, laparams=None, outdir=None):\n  404:         PDFConverter.__init__(self, rsrcmgr, outfp, codec=codec, pageno=pageno, laparams=laparams)\n  405          self.outdir = outdir\n  406          self.write_header()\n  ...\n  408  \n  409      def write_header(self):\n  410:         self.outfp.write('<?xml version=\"1.0\" encoding=\"%s\" ?>\\n' % self.codec)\n  411          self.outfp.write('<pages>\\n')\n  412          return\n  ...\n  417      \n  418      def write_text(self, text):\n  419:         self.outfp.write(enc(text, self.codec))\n  420          return\n  421  \n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\build\\lib\\pdfminer\\encodingdb.py:\n    3  import re\n    4  from psparser import PSLiteral\n    5: from glyphlist import glyphname2unicode\n    6  from latin_enc import ENCODING\n    7  \n    8  \n    9: ##  name2unicode\n   10  ##\n   11  STRIP_NAME = re.compile(r'[0-9]+')\n   12: def name2unicode(name):\n   13:     \"\"\"Converts Adobe glyph names to Unicode numbers.\"\"\"\n   14:     if name in glyphname2unicode:\n   15:         return glyphname2unicode[name]\n   16      m = STRIP_NAME.search(name)\n   17      if not m: raise KeyError(name)\n   ..\n   23  class EncodingDB(object):\n   24  \n   25:     std2unicode = {}\n   26:     mac2unicode = {}\n   27:     win2unicode = {}\n   28:     pdf2unicode = {}\n   29      for (name,std,mac,win,pdf) in ENCODING:\n   30:         c = name2unicode(name)\n   31:         if std: std2unicode[std] = c\n   32:         if mac: mac2unicode[mac] = c\n   33:         if win: win2unicode[win] = c\n   34:         if pdf: pdf2unicode[pdf] = c\n   35  \n   36      encodings = {\n   37:       'StandardEncoding': std2unicode,\n   38:       'MacRomanEncoding': mac2unicode,\n   39:       'WinAnsiEncoding': win2unicode,\n   40:       'PDFDocEncoding': pdf2unicode,\n   41        }\n   42  \n   43      @classmethod\n   44      def get_encoding(klass, name, diff=None):\n   45:         cid2unicode = klass.encodings.get(name, klass.std2unicode)\n   46          if diff:\n   47:             cid2unicode = cid2unicode.copy()\n   48              cid = 0\n   49              for x in diff:\n   ..\n   52                  elif isinstance(x, PSLiteral):\n   53                      try:\n   54:                         cid2unicode[cid] = name2unicode(x.name)\n   55                      except KeyError:\n   56                          pass\n   57                      cid += 1\n   58:         return cid2unicode\n   59  \n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\build\\lib\\pdfminer\\glyphlist.py:\n    1  #!/usr/bin/env python2\n    2  \n    3: \"\"\" Mappings from Adobe glyph names to Unicode characters.\n    4  \n    5  In some CMap tables, Adobe glyph names are used for specifying\n    6: Unicode characters instead of using decimal/hex character code.\n    7  \n    8  The following data was taken by\n    .\n   48  # Date:          September 20, 2002\n   49  #\n   50: # See http://partners.adobe.com/asn/developer/typeforum/unicodegn.html\n   51  #\n   52  # Format: Semicolon-delimited fields:\n   53  #            (1) glyph name\n   54: #            (2) Unicode scalar value\n   55  \n   56: glyphname2unicode = {\n   57   'A': u'\\u0041',\n   58   'AE': u'\\u00C6',\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\build\\lib\\pdfminer\\lzw.py:\n    7  \n    8  \n    9: ##  LZWDecoder\n   10  ##\n   11: class LZWDecoder(object):\n   12  \n   13      debug = 0\n   ..\n   46          return v\n   47  \n   48:     def feed(self, code):\n   49          x = ''\n   50:         if code == 256:\n   51              self.table = [ chr(c) for c in xrange(256) ] # 0-255\n   52              self.table.append(None) # 256\n   ..\n   54              self.prevbuf = ''\n   55              self.nbits = 9\n   56:         elif code == 257:\n   57              pass\n   58          elif not self.prevbuf:\n   59:             x = self.prevbuf = self.table[code]\n   60          else:\n   61:             if code < len(self.table):\n   62:                 x = self.table[code]\n   63                  self.table.append(self.prevbuf+x[0])\n   64              else:\n   65                  self.table.append(self.prevbuf+self.prevbuf[0])\n   66:                 x = self.table[code]\n   67              l = len(self.table)\n   68              if l == 511:\n   ..\n   78          while 1:\n   79              try:\n   80:                 code = self.readbits(self.nbits)\n   81              except EOFError:\n   82                  break\n   83:             x = self.feed(code)\n   84              yield x\n   85              if self.debug:\n   86:                 print >>sys.stderr, ('nbits=%d, code=%d, output=%r, table=%r' %\n   87:                                      (self.nbits, code, x, self.table[258:]))\n   88          return\n   89  \n   90: # lzwdecode\n   91: def lzwdecode(data):\n   92      \"\"\"\n   93:     >>> lzwdecode('\\x80\\x0b\\x60\\x50\\x22\\x0c\\x0c\\x85\\x01')\n   94      '\\x2d\\x2d\\x2d\\x2d\\x2d\\x41\\x2d\\x2d\\x2d\\x42'\n   95      \"\"\"\n   96      fp = StringIO(data)\n   97:     return ''.join(LZWDecoder(fp).run())\n   98  \n   99  if __name__ == '__main__':\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\build\\lib\\pdfminer\\pdfdevice.py:\n    3  from utils import mult_matrix, translate_matrix\n    4  from utils import enc, bbox2str\n    5: from pdffont import PDFUnicodeNotDefined\n    6  \n    7  \n    .\n   84                  needcharspace = True\n   85              else:\n   86:                 for cid in font.decode(obj):\n   87                      if needcharspace:\n   88                          x += charspace\n   ..\n  102                  needcharspace = True\n  103              else:\n  104:                 for cid in font.decode(obj):\n  105                      if needcharspace:\n  106                          y += charspace\n  ...\n  120  class TagExtractor(PDFDevice):\n  121  \n  122:     def __init__(self, rsrcmgr, outfp, codec='utf-8', debug=0):\n  123          PDFDevice.__init__(self, rsrcmgr)\n  124          self.outfp = outfp\n  125:         self.codec = codec\n  126          self.debug = debug\n  127          self.pageno = 0\n  ...\n  134          for obj in seq:\n  135              if not isinstance(obj, str): continue\n  136:             chars = font.decode(obj)\n  137              for cid in chars:\n  138                  try:\n  139                      char = font.to_unichr(cid)\n  140                      text += char\n  141:                 except PDFUnicodeNotDefined:\n  142                      pass\n  143:         self.outfp.write(enc(text, self.codec))\n  144          return\n  145  \n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\build\\lib\\pdfminer\\pdffont.py:\n    6  except ImportError:\n    7      from StringIO import StringIO\n    8: from cmapdb import CMapDB, CMapParser, FileUnicodeMap, CMap\n    9: from encodingdb import EncodingDB, name2unicode\n   10  from psparser import PSStackParser\n   11  from psparser import PSSyntaxError, PSEOF\n   ..\n   89      def __init__(self, data):\n   90          PSStackParser.__init__(self, data)\n   91:         self._cid2unicode = {}\n   92          return\n   93  \n   ..\n   99                  break\n  100              try:\n  101:                 self._cid2unicode[cid] = name2unicode(name)\n  102              except KeyError:\n  103                  pass\n  104:         return self._cid2unicode\n  105      \n  106      def do_keyword(self, pos, token):\n  ...\n  291          self.nglyphs = len(self.charstring)\n  292          # Encodings\n  293:         self.code2gid = {}\n  294:         self.gid2code = {}\n  295          self.fp.seek(encoding_pos)\n  296          format = self.fp.read(1)\n  ...\n  298              # Format 0\n  299              (n,) = struct.unpack('B', self.fp.read(1))\n  300:             for (code,gid) in enumerate(struct.unpack('B'*n, self.fp.read(n))):\n  301:                 self.code2gid[code] = gid\n  302:                 self.gid2code[gid] = code\n  303          elif format == '\\x01':\n  304              # Format 1\n  305              (n,) = struct.unpack('B', self.fp.read(1))\n  306:             code = 0\n  307              for i in xrange(n):\n  308                  (first,nleft) = struct.unpack('BB', self.fp.read(2))\n  309                  for gid in xrange(first,first+nleft+1):\n  310:                     self.code2gid[code] = gid\n  311:                     self.gid2code[gid] = code\n  312:                     code += 1\n  313          else:\n  314              raise ValueError('unsupported encoding format: %r' % format)\n  ...\n  342          else:\n  343              raise ValueError('unsupported charset format: %r' % format)\n  344:         #print self.code2gid\n  345          #print self.name2gid\n  346          #assert 0\n  ...\n  370          return\n  371  \n  372:     def create_unicode_map(self):\n  373          if 'cmap' not in self.tables:\n  374              raise TrueTypeFont.CMapNotFound\n  ...\n  395                  hdrs = []\n  396                  for i in xrange(nhdrs):\n  397:                     (firstcode,entcount,delta,offset) = struct.unpack('>HHhH', fp.read(8))\n  398:                     hdrs.append((i,firstcode,entcount,delta,fp.tell()-2+offset))\n  399:                 for (i,firstcode,entcount,delta,pos) in hdrs:\n  400                      if not entcount: continue\n  401:                     first = firstcode + (firstbytes[i] << 8)\n  402                      fp.seek(pos)\n  403                      for c in xrange(entcount):\n  ...\n  425              else:\n  426                  assert 0\n  427:         # create unicode map\n  428:         unicode_map = FileUnicodeMap()\n  429          for (char,gid) in char2gid.iteritems():\n  430:             unicode_map.add_cid2unichr(gid, char)\n  431:         return unicode_map\n  432  \n  433  \n  ...\n  436  \n  437  class PDFFontError(PDFException): pass\n  438: class PDFUnicodeNotDefined(PDFFontError): pass\n  439  \n  440  LITERAL_STANDARD_ENCODING = LIT('StandardEncoding')\n  ...\n  470          return False\n  471  \n  472:     def decode(self, bytes):\n  473          return map(ord, bytes)\n  474  \n  ...\n  496  \n  497      def string_width(self, s):\n  498:         return sum( self.char_width(cid) for cid in self.decode(s) )\n  499  \n  500  \n  ...\n  513              name = literal_name(encoding.get('BaseEncoding', LITERAL_STANDARD_ENCODING))\n  514              diff = list_value(encoding.get('Differences', None))\n  515:             self.cid2unicode = EncodingDB.get_encoding(name, diff)\n  516          else:\n  517:             self.cid2unicode = EncodingDB.get_encoding(literal_name(encoding))\n  518:         self.unicode_map = None\n  519:         if 'ToUnicode' in spec:\n  520:             strm = stream_value(spec['ToUnicode'])\n  521:             self.unicode_map = FileUnicodeMap()\n  522:             CMapParser(self.unicode_map, StringIO(strm.get_data())).run()\n  523          PDFFont.__init__(self, descriptor, widths)\n  524          return\n  525  \n  526      def to_unichr(self, cid):\n  527:         if self.unicode_map:\n  528              try:\n  529:                 return self.unicode_map.get_unichr(cid)\n  530              except KeyError:\n  531                  pass\n  532          try:\n  533:             return self.cid2unicode[cid]\n  534          except KeyError:\n  535:             raise PDFUnicodeNotDefined(None, cid)\n  536  \n  537  # PDFType1Font\n  ...\n  560              data = self.fontfile.get_data()[:length1]\n  561              parser = Type1FontHeaderParser(StringIO(data))\n  562:             self.cid2unicode = parser.get_encoding()\n  563          return\n  564  \n  ...\n  631              ttf = TrueTypeFont(self.basefont,\n  632                                 StringIO(self.fontfile.get_data()))\n  633:         self.unicode_map = None\n  634:         if 'ToUnicode' in spec:\n  635:             strm = stream_value(spec['ToUnicode'])\n  636:             self.unicode_map = FileUnicodeMap()\n  637:             CMapParser(self.unicode_map, StringIO(strm.get_data())).run()\n  638          elif self.cidcoding == 'Adobe-Identity':\n  639              if ttf:\n  640                  try:\n  641:                     self.unicode_map = ttf.create_unicode_map()\n  642                  except TrueTypeFont.CMapNotFound:\n  643                      pass\n  644          else:\n  645              try:\n  646:                 self.unicode_map = CMapDB.get_unicode_map(self.cidcoding, self.cmap.is_vertical())\n  647              except CMapDB.CMapNotFound, e:\n  648                  pass\n  ...\n  675          return True\n  676  \n  677:     def decode(self, bytes):\n  678:         return self.cmap.decode(bytes)\n  679  \n  680      def char_disp(self, cid):\n  ...\n  684      def to_unichr(self, cid):\n  685          try:\n  686:             if not self.unicode_map: raise KeyError(cid)\n  687:             return self.unicode_map.get_unichr(cid)\n  688          except KeyError:\n  689:             raise PDFUnicodeNotDefined(self.cidcoding, cid)\n  690  \n  691  \n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\build\\lib\\pdfminer\\pdfinterp.py:\n  188                  assert dfonts\n  189                  subspec = dict_value(dfonts[0]).copy()\n  190:                 for k in ('Encoding', 'ToUnicode'):\n  191                      if k in spec:\n  192                          subspec[k] = resolve1(spec[k])\n  ...\n  787                  if hasattr(self, method):\n  788                      func = getattr(self, method)\n  789:                     nargs = func.func_code.co_argcount-1\n  790                      if nargs:\n  791                          args = self.pop(nargs)\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\build\\lib\\pdfminer\\pdfparser.py:\n   22  from arcfour import Arcfour\n   23  from utils import choplist, nunpack\n   24: from utils import decode_text, ObjIdRange\n   25  \n   26  \n   ..\n  526              if 'Title' in entry:\n  527                  if 'A' in entry or 'Dest' in entry:\n  528:                     title = decode_text(str_value(entry['Title']))\n  529                      dest = entry.get('Dest')\n  530                      action = entry.get('A')\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\build\\lib\\pdfminer\\pdftypes.py:\n    2  import sys\n    3  import zlib\n    4: from lzw import lzwdecode\n    5: from ascii85 import ascii85decode, asciihexdecode\n    6: from runlength import rldecode\n    7  from psparser import PSException, PSObject\n    8  from psparser import LIT, KWD, STRICT\n    .\n   11  \n   12  # Abbreviation of Filter names in PDF 4.8.6. \"Inline Images\"\n   13: LITERALS_FLATE_DECODE = (LIT('FlateDecode'), LIT('Fl'))\n   14: LITERALS_LZW_DECODE = (LIT('LZWDecode'), LIT('LZW'))\n   15: LITERALS_ASCII85_DECODE = (LIT('ASCII85Decode'), LIT('A85'))\n   16: LITERALS_ASCIIHEX_DECODE = (LIT('ASCIIHexDecode'), LIT('AHx'))\n   17: LITERALS_RUNLENGTH_DECODE = (LIT('RunLengthDecode'), LIT('RL'))\n   18: LITERALS_CCITTFAX_DECODE = (LIT('CCITTFaxDecode'), LIT('CCF'))\n   19: LITERALS_DCT_DECODE = (LIT('DCTDecode'), LIT('DCT'))\n   20  \n   21  \n   ..\n  194          return [ filters ]\n  195  \n  196:     def decode(self):\n  197          assert self.data is None and self.rawdata != None\n  198          data = self.rawdata\n  ...\n  206              return\n  207          for f in filters:\n  208:             if f in LITERALS_FLATE_DECODE:\n  209                  # will get errors if the document is encrypted.\n  210                  try:\n  ...\n  214                          raise PDFException('Invalid zlib bytes: %r, %r' % (e, data))\n  215                      data = ''\n  216:             elif f in LITERALS_LZW_DECODE:\n  217:                 data = lzwdecode(data)\n  218:             elif f in LITERALS_ASCII85_DECODE:\n  219:                 data = ascii85decode(data)\n  220:             elif f in LITERALS_ASCIIHEX_DECODE:\n  221:                 data = asciihexdecode(data)\n  222:             elif f in LITERALS_RUNLENGTH_DECODE:\n  223:                 data = rldecode(data)\n  224:             elif f in LITERALS_CCITTFAX_DECODE:\n  225:                 #data = ccittfaxdecode(data)\n  226                  raise PDFNotImplementedError('Unsupported filter: %r' % f)\n  227              elif f == LITERAL_CRYPT:\n  ...\n  231                  raise PDFNotImplementedError('Unsupported filter: %r' % f)\n  232              # apply predictors\n  233:             params = self.get_any(('DP', 'DecodeParms', 'FDecodeParms'), {})\n  234              if 'Predictor' in params and 'Columns' in params:\n  235                  pred = int_value(params['Predictor'])\n  ...\n  254      def get_data(self):\n  255          if self.data is None:\n  256:             self.decode()\n  257          return self.data\n  258  \n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\build\\lib\\pdfminer\\rijndael.py:\n    3  \"\"\" Python implementation of Rijndael encryption algorithm.\n    4  \n    5: This code is in the public domain.\n    6  \n    7: This code is based on a public domain C implementation\n    8  by Philip J. Erdelsky:\n    9    http://www.efgh.com/software/rijndael.htm\n   ..\n 1035  \n 1036      \"\"\"\n 1037:     >>> key = '00010203050607080a0b0c0d0f101112'.decode('hex')\n 1038:     >>> ciphertext = 'd8f532538289ef7d06b506a4fd5be9c9'.decode('hex')\n 1039:     >>> RijndaelDecryptor(key, 128).decrypt(ciphertext).encode('hex')\n 1040      '506812a45f08c889b97f5980038b8359'\n 1041      \"\"\"\n ....\n 1056  \n 1057      \"\"\"\n 1058:     >>> key = '00010203050607080a0b0c0d0f101112'.decode('hex')\n 1059:     >>> plaintext = '506812a45f08c889b97f5980038b8359'.decode('hex')\n 1060:     >>> RijndaelEncryptor(key, 128).encrypt(plaintext).encode('hex')\n 1061      'd8f532538289ef7d06b506a4fd5be9c9'\n 1062      \"\"\"\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\build\\lib\\pdfminer\\runlength.py:\n    1  #!/usr/bin/env python2\n    2  #\n    3: # RunLength decoder (Adobe version) implementation based on PDF Reference\n    4  # version 1.4 section 3.3.4.\n    5  #\n    .\n    9  import sys\n   10  \n   11: def rldecode(data):\n   12      \"\"\"\n   13:     RunLength decoder (Adobe version) implementation based on PDF Reference\n   14      version 1.4 section 3.3.4:\n   15:         The RunLengthDecode filter decodes data that has been encoded in a\n   16:         simple byte-oriented format based on run length. The encoded data\n   17          is a sequence of runs, where each run consists of a length byte\n   18          followed by 1 to 128 bytes of data. If the length byte is in the\n   ..\n   23          denotes EOD.\n   24      >>> s = \"\\x05123456\\xfa7\\x04abcde\\x80junk\"\n   25:     >>> rldecode(s)\n   26      '1234567777777abcde'\n   27      \"\"\"\n   28:     decoded = []\n   29      i=0\n   30      while i < len(data):\n   ..\n   36              run = data[i+1:(i+1)+(length+1)]\n   37              #print \"length=%d, run=%s\" % (length+1,run)\n   38:             decoded.append(run)\n   39              i = (i+1) + (length+1)\n   40          if length > 128:\n   41              run = data[i+1]*(257-length)\n   42              #print \"length=%d, run=%s\" % (257-length,run)\n   43:             decoded.append(run)\n   44              i = (i+1) + 1\n   45:     return ''.join(decoded)\n   46  \n   47  \n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\build\\lib\\pdfminer\\utils.py:\n  116          raise TypeError('invalid length: %d' % l)\n  117  \n  118: # decode_text\n  119  PDFDocEncoding = ''.join( unichr(x) for x in (\n  120    0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007,\n  ...\n  151    0x00f8, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x00fd, 0x00fe, 0x00ff,\n  152  ))\n  153: def decode_text(s):\n  154:     \"\"\"Decodes a PDFDocEncoding string to Unicode.\"\"\"\n  155      if s.startswith('\\xfe\\xff'):\n  156:         return unicode(s[2:], 'utf-16be', 'ignore')\n  157      else:\n  158          return ''.join( PDFDocEncoding[ord(c)] for c in s )\n  159  \n  160  # enc\n  161: def enc(x, codec='ascii'):\n  162:     \"\"\"Encodes a string for SGML/XML/HTML\"\"\"\n  163      x = x.replace('&','&amp;').replace('>','&gt;').replace('<','&lt;').replace('\"','&quot;')\n  164:     return x.encode(codec, 'xmlcharrefreplace')\n  165  \n  166  def bbox2str((x0,y0,x1,y1)):\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\build\\scripts-2.7\\dumppdf.py:\n   19  \n   20  # dumpxml\n   21: def dumpxml(out, obj, codec=None):\n   22      if obj is None:\n   23          out.write('<null />')\n   ..\n   47  \n   48      if isinstance(obj, PDFStream):\n   49:         if codec == 'raw':\n   50              out.write(obj.get_rawdata())\n   51:         elif codec == 'binary':\n   52              out.write(obj.get_data())\n   53          else:\n   ..\n   55              dumpxml(out, obj.attrs)\n   56              out.write('\\n</props>\\n')\n   57:             if codec == 'text':\n   58                  data = obj.get_data()\n   59                  out.write('<data size=\"%d\">%s</data>\\n' % (len(data), e(data)))\n   ..\n   88  \n   89  # dumpallobjs\n   90: def dumpallobjs(out, doc, codec=None):\n   91      out.write('<pdf>')\n   92      for xref in doc.xrefs:\n   ..\n   96                  if obj is None: continue\n   97                  out.write('<object id=\"%d\">\\n' % objid)\n   98:                 dumpxml(out, obj, codec=codec)\n   99                  out.write('\\n</object>\\n\\n')\n  100              except:\n  ...\n  106  # dumpoutline\n  107  def dumpoutline(outfp, fname, objids, pagenos, password='',\n  108:                 dumpall=False, codec=None):\n  109      doc = PDFDocument()\n  110      fp = file(fname, 'rb')\n  ...\n  137                          dest = resolve_dest(action['D'])\n  138                          pageno = pages[dest[0].objid]\n  139:             s = e(title).encode('utf-8', 'xmlcharrefreplace')\n  140              outfp.write('<outline level=\"%r\" title=\"%s\">\\n' % (level, s))\n  141              if dest is not None:\n  ...\n  155  # dumppdf\n  156  def dumppdf(outfp, fname, objids, pagenos, password='',\n  157:             dumpall=False, codec=None):\n  158      doc = PDFDocument()\n  159      fp = file(fname, 'rb')\n  ...\n  165          for objid in objids:\n  166              obj = doc.getobj(objid)\n  167:             dumpxml(outfp, obj, codec=codec)\n  168      if pagenos:\n  169          for (pageno,page) in enumerate(doc.get_pages()):\n  170              if pageno in pagenos:\n  171:                 if codec:\n  172                      for obj in page.contents:\n  173                          obj = stream_value(obj)\n  174:                         dumpxml(outfp, obj, codec=codec)\n  175                  else:\n  176                      dumpxml(outfp, page.attrs)\n  177      if dumpall:\n  178:         dumpallobjs(outfp, doc, codec=codec)\n  179      if (not objids) and (not pagenos) and (not dumpall):\n  180          dumptrailers(outfp, doc)\n  181      fp.close()\n  182:     if codec not in ('raw','binary'):\n  183          outfp.write('\\n')\n  184      return\n  ...\n  199      objids = []\n  200      pagenos = set()\n  201:     codec = None\n  202      password = ''\n  203      dumpall = False\n  ...\n  210          elif k == '-P': password = v\n  211          elif k == '-a': dumpall = True\n  212:         elif k == '-r': codec = 'raw'\n  213:         elif k == '-b': codec = 'binary'\n  214:         elif k == '-t': codec = 'text'\n  215          elif k == '-T': proc = dumpoutline\n  216          elif k == '-o': outfp = file(v, 'wb')\n  ...\n  221      for fname in args:\n  222          proc(outfp, fname, objids, pagenos, password=password,\n  223:              dumpall=dumpall, codec=codec)\n  224      return\n  225  \n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\build\\scripts-2.7\\latin2ascii.py:\n  113      import getopt, fileinput\n  114      def usage():\n  115:         print 'usage: %s [-c codec] file ...' % argv[0]\n  116          return 100\n  117      try:\n  ...\n  120          return usage()\n  121      if not args: return usage()\n  122:     codec = 'utf-8'\n  123      for (k, v) in opts:\n  124:         if k == '-c': codec = v\n  125      for line in fileinput.input(args):\n  126:         line = latin2ascii(unicode(line, codec, 'ignore'))\n  127:         sys.stdout.write(line.encode('ascii', 'replace'))\n  128      return\n  129  \n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\build\\scripts-2.7\\pdf2txt.py:\n   14          print ('usage: %s [-d] [-p pagenos] [-m maxpages] [-P password] [-o output] [-C] '\n   15                 '[-n] [-A] [-V] [-M char_margin] [-L line_margin] [-W word_margin] [-F boxes_flow] '\n   16:                '[-Y layout_mode] [-O output_dir] [-t text|html|xml|tag] [-c codec] [-s scale] file ...' % argv[0])\n   17          return 100\n   18      try:\n   ..\n   32      outdir = None\n   33      layoutmode = 'normal'\n   34:     codec = 'utf-8'\n   35      pageno = 1\n   36      scale = 1\n   ..\n   55          elif k == '-O': outdir = v\n   56          elif k == '-t': outtype = v\n   57:         elif k == '-c': codec = v\n   58          elif k == '-s': scale = float(v)\n   59      #\n   ..\n   80          outfp = sys.stdout\n   81      if outtype == 'text':\n   82:         device = TextConverter(rsrcmgr, outfp, codec=codec, laparams=laparams)\n   83      elif outtype == 'xml':\n   84:         device = XMLConverter(rsrcmgr, outfp, codec=codec, laparams=laparams, outdir=outdir)\n   85      elif outtype == 'html':\n   86:         device = HTMLConverter(rsrcmgr, outfp, codec=codec, scale=scale,\n   87                                 layoutmode=layoutmode, laparams=laparams, outdir=outdir)\n   88      elif outtype == 'tag':\n   89:         device = TagExtractor(rsrcmgr, outfp, codec=codec)\n   90      else:\n   91          return usage()\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\pdfminer\\arcfour.py:\n    3  \"\"\" Python implementation of Arcfour encryption algorithm.\n    4  \n    5: This code is in the public domain.\n    6  \n    7  \"\"\"\n    .\n   12  \n   13      \"\"\"\n   14:     >>> Arcfour('Key').process('Plaintext').encode('hex')\n   15      'bbf316e8d940af0ad3'\n   16:     >>> Arcfour('Wiki').process('pedia').encode('hex')\n   17      '1021bf0420'\n   18:     >>> Arcfour('Secret').process('Attack at dawn').encode('hex')\n   19      '45a01f645fc35b383552544b9bf5'\n   20      \"\"\"\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\pdfminer\\ascii85.py:\n    1  #!/usr/bin/env python2\n    2  \n    3: \"\"\" Python implementation of ASCII85/ASCIIHex decoder (Adobe version).\n    4  \n    5: This code is in the public domain.\n    6  \n    7  \"\"\"\n    .\n   10  import struct\n   11  \n   12: # ascii85decode(data)\n   13: def ascii85decode(data):\n   14      \"\"\"\n   15:     In ASCII85 encoding, every four bytes are encoded with five ASCII\n   16      letters, using 85 different types of characters (as 256**4 < 85**5).\n   17      When the length of the original bytes is not a multiple of 4, a special\n   ..\n   24        http://en.wikipedia.org/w/index.php?title=Ascii85\n   25      \n   26:     >>> ascii85decode('9jqo^BlbD-BleB1DJ+*+F(f,q')\n   27      'Man is distinguished'\n   28:     >>> ascii85decode('E,9)oF*2M7/c~>')\n   29      'pleasure.'\n   30      \"\"\"\n   ..\n   49      return out\n   50  \n   51: # asciihexdecode(data)\n   52  hex_re = re.compile(r'([a-f\\d]{2})', re.IGNORECASE)\n   53  trail_re = re.compile(r'^(?:[a-f\\d]{2}|\\s)*([a-f\\d])[\\s>]*$', re.IGNORECASE)\n   54: def asciihexdecode(data):\n   55      \"\"\"\n   56:     ASCIIHexDecode filter: PDFReference v1.4 section 3.3.1\n   57      For each pair of ASCII hexadecimal digits (0-9 and A-F or a-f), the\n   58:     ASCIIHexDecode filter produces one byte of binary data. All white-space\n   59      characters are ignored. A right angle bracket character (>) indicates\n   60      EOD. Any other characters will cause an error. If the filter encounters\n   ..\n   62      will behave as if a 0 followed the last digit.\n   63      \n   64:     >>> asciihexdecode('61 62 2e6364   65')\n   65      'ab.cde'\n   66:     >>> asciihexdecode('61 62 2e6364   657>')\n   67      'ab.cdep'\n   68:     >>> asciihexdecode('7>')\n   69      'p'\n   70      \"\"\"\n   71:     decode = (lambda hx: chr(int(hx, 16)))\n   72:     out = map(decode, hex_re.findall(data))\n   73      m = trail_re.search(data)\n   74      if m:\n   75:         out.append(decode(\"%c0\" % m.group(1)))\n   76      return ''.join(out)\n   77  \n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\pdfminer\\cmapdb.py:\n    3  \"\"\" Adobe character mapping (CMap) support.\n    4  \n    5: CMaps provide the mapping between character codes and Unicode\n    6  code-points to character ids (CIDs).\n    7  \n    .\n   24  from psparser import PSLiteral, PSKeyword\n   25  from psparser import literal_name, keyword_name\n   26: from encodingdb import name2unicode\n   27  from utils import choplist, nunpack\n   28  \n   ..\n   37      debug = 0\n   38  \n   39:     def __init__(self, code2cid=None):\n   40:         self.code2cid = code2cid or {}\n   41          return\n   42  \n   ..\n   54                  else:\n   55                      dst[k] = v\n   56:         copy(self.code2cid, cmap.code2cid)\n   57          return\n   58  \n   59:     def decode(self, code):\n   60          if self.debug:\n   61:             print >>sys.stderr, 'decode: %r, %r' % (self, code)\n   62:         d = self.code2cid\n   63:         for c in code:\n   64              c = ord(c)\n   65              if c in d:\n   ..\n   67                  if isinstance(d, int):\n   68                      yield d\n   69:                     d = self.code2cid\n   70              else:\n   71:                 d = self.code2cid\n   72          return\n   73  \n   74:     def dump(self, out=sys.stdout, code2cid=None, code=None):\n   75:         if code2cid is None:\n   76:             code2cid = self.code2cid\n   77:             code = ()\n   78:         for (k,v) in sorted(code2cid.iteritems()):\n   79:             c = code+(k,)\n   80              if isinstance(v, int):\n   81:                 out.write('code %r = cid %d\\n' % (c,v))\n   82              else:\n   83:                 self.dump(out=out, code2cid=v, code=c)\n   84          return\n   85      \n   ..\n   96          return self.vertical\n   97  \n   98:     def decode(self, code):\n   99:         n = len(code)/2\n  100          if n:\n  101:             return struct.unpack('>%dH' % n, code)\n  102          else:\n  103              return ()\n  ...\n  105              \n  106  \n  107: ##  UnicodeMap\n  108  ##\n  109: class UnicodeMap(object):\n  110  \n  111      debug = 0\n  ...\n  122      def dump(self, out=sys.stdout):\n  123          for (k,v) in sorted(self.cid2unichr.iteritems()):\n  124:             out.write('cid %d = unicode %r\\n' % (k,v))\n  125          return\n  126  \n  ...\n  145          return\n  146  \n  147:     def add_code2cid(self, code, cid):\n  148:         assert isinstance(code, str) and isinstance(cid, int)\n  149:         d = self.code2cid\n  150:         for c in code[:-1]:\n  151              c = ord(c)\n  152              if c in d:\n  ...\n  156                  d[c] = t\n  157                  d =t\n  158:         c = ord(code[-1])\n  159          d[c] = cid\n  160          return\n  161  \n  162  \n  163: ##  FileUnicodeMap\n  164  ##\n  165: class FileUnicodeMap(UnicodeMap):\n  166      \n  167      def __init__(self):\n  168:         UnicodeMap.__init__(self)\n  169          self.attrs = {}\n  170          return\n  171  \n  172      def __repr__(self):\n  173:         return '<UnicodeMap: %s>' % self.attrs.get('CMapName')\n  174  \n  175      def set_attr(self, k, v):\n  ...\n  177          return\n  178  \n  179:     def add_cid2unichr(self, cid, code):\n  180          assert isinstance(cid, int)\n  181:         if isinstance(code, PSLiteral):\n  182              # Interpret as an Adobe glyph name.\n  183:             self.cid2unichr[cid] = name2unicode(code.name)\n  184:         elif isinstance(code, str):\n  185              # Interpret as UTF-16BE.\n  186:             self.cid2unichr[cid] = unicode(code, 'UTF-16BE', 'ignore')\n  187:         elif isinstance(code, int):\n  188:             self.cid2unichr[cid] = unichr(code)\n  189          else:\n  190:             raise TypeError(code)\n  191          return\n  192  \n  ...\n  197  \n  198      def __init__(self, name, module):\n  199:         CMap.__init__(self, module.CODE2CID)\n  200          self.name = name\n  201          self._is_vertical = module.IS_VERTICAL\n  ...\n  209      \n  210  \n  211: ##  PyUnicodeMap\n  212  ##\n  213: class PyUnicodeMap(UnicodeMap):\n  214      \n  215      def __init__(self, name, module, vertical):\n  ...\n  218          else:\n  219              cid2unichr = module.CID2UNICHR_H\n  220:         UnicodeMap.__init__(self, cid2unichr)\n  221          self.name = name\n  222          return\n  223  \n  224      def __repr__(self):\n  225:         return '<PyUnicodeMap: %s>' % (self.name)\n  226  \n  227  \n  ...\n  268  \n  269      @classmethod\n  270:     def get_unicode_map(klass, name, vertical=False):\n  271          try:\n  272              return klass._umap_cache[name][vertical]\n  273          except KeyError:\n  274              pass\n  275:         data = klass._load_data('to-unicode-%s' % name)\n  276:         klass._umap_cache[name] = umaps = [PyUnicodeMap(name, data, v) for v in (False, True)]\n  277          return umaps[vertical]\n  278  \n  ...\n  324              return\n  325  \n  326:         if name == 'begincodespacerange':\n  327              self.popall()\n  328              return\n  329:         if name == 'endcodespacerange':\n  330              self.popall()\n  331              return\n  ...\n  350                  for i in xrange(e1-s1+1):\n  351                      x = sprefix+struct.pack('>L',s1+i)[-vlen:]\n  352:                     self.cmap.add_code2cid(x, cid+i)\n  353              return\n  354  \n  ...\n  358          if name == 'endcidchar':\n  359              objs = [ obj for (_,obj) in self.popall() ]\n  360:             for (cid,code) in choplist(2, objs):\n  361:                 if isinstance(code, str) and isinstance(cid, str):\n  362:                     self.cmap.add_code2cid(code, nunpack(cid))\n  363              return\n  364  \n  ...\n  368          if name == 'endbfrange':\n  369              objs = [ obj for (_,obj) in self.popall() ]\n  370:             for (s,e,code) in choplist(3, objs):\n  371                  if (not isinstance(s, str) or not isinstance(e, str) or\n  372                      len(s) != len(e)): continue\n  ...\n  374                  e1 = nunpack(e)\n  375                  #assert s1 <= e1\n  376:                 if isinstance(code, list):\n  377                      for i in xrange(e1-s1+1):\n  378:                         self.cmap.add_cid2unichr(s1+i, code[i])\n  379                  else:\n  380:                     var = code[-4:]\n  381                      base = nunpack(var)\n  382:                     prefix = code[:-4]\n  383                      vlen = len(var)\n  384                      for i in xrange(e1-s1+1):\n  ...\n  392          if name == 'endbfchar':\n  393              objs = [ obj for (_,obj) in self.popall() ]\n  394:             for (cid,code) in choplist(2, objs):\n  395:                 if isinstance(cid, str) and isinstance(code, str):\n  396:                     self.cmap.add_cid2unichr(nunpack(cid), code)\n  397              return\n  398  \n  ...\n  412      for fname in args:\n  413          fp = file(fname, 'rb')\n  414:         cmap = FileUnicodeMap()\n  415          #cmap = FileCMap()\n  416          CMapParser(cmap, fp).run()\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\pdfminer\\converter.py:\n    2  import sys, os.path\n    3  from pdfdevice import PDFDevice, PDFTextDevice\n    4: from pdffont import PDFUnicodeNotDefined\n    5: from pdftypes import LITERALS_DCT_DECODE\n    6  from pdfcolor import LITERAL_DEVICE_GRAY, LITERAL_DEVICE_RGB\n    7  from layout import LTContainer, LTPage, LTText, LTLine, LTRect, LTCurve\n    .\n   96          try:\n   97              text = font.to_unichr(cid)\n   98:             assert isinstance(text, unicode), text\n   99:         except PDFUnicodeNotDefined:\n  100              text = self.handle_undefined_char(font, cid)\n  101          textwidth = font.char_width(cid)\n  ...\n  135  class PDFConverter(PDFLayoutAnalyzer):\n  136  \n  137:     def __init__(self, rsrcmgr, outfp, codec='utf-8', pageno=1, laparams=None):\n  138          PDFLayoutAnalyzer.__init__(self, rsrcmgr, pageno=pageno, laparams=laparams)\n  139          self.outfp = outfp\n  140:         self.codec = codec\n  141          return\n  142  \n  ...\n  144          stream = image.stream\n  145          filters = stream.get_filters()\n  146:         if len(filters) == 1 and filters[0] in LITERALS_DCT_DECODE:\n  147              ext = '.jpg'\n  148              data = stream.get_rawdata()\n  ...\n  168  class TextConverter(PDFConverter):\n  169  \n  170:     def __init__(self, rsrcmgr, outfp, codec='utf-8', pageno=1, laparams=None,\n  171                   showpageno=False):\n  172:         PDFConverter.__init__(self, rsrcmgr, outfp, codec=codec, pageno=pageno, laparams=laparams)\n  173          self.showpageno = showpageno\n  174          return\n  175  \n  176      def write_text(self, text):\n  177:         self.outfp.write(text.encode(self.codec, 'ignore'))\n  178          return\n  179  \n  ...\n  221          }\n  222  \n  223:     def __init__(self, rsrcmgr, outfp, codec='utf-8', pageno=1, laparams=None, \n  224                   scale=1, fontscale=0.7, layoutmode='normal', showpageno=True,\n  225                   pagemargin=50, outdir=None,\n  226                   rect_colors={'curve':'black', 'page':'gray'},\n  227                   text_colors={'char':'black'}):\n  228:         PDFConverter.__init__(self, rsrcmgr, outfp, codec=codec, pageno=pageno, laparams=laparams)\n  229          self.scale = scale\n  230          self.fontscale = fontscale\n  ...\n  250      def write_header(self):\n  251          self.write('<html><head>\\n')\n  252:         self.write('<meta http-equiv=\"Content-Type\" content=\"text/html; charset=%s\">\\n' % self.codec)\n  253          self.write('</head><body>\\n')\n  254          return\n  ...\n  261  \n  262      def write_text(self, text):\n  263:         self.write(enc(text, self.codec))\n  264          return\n  265  \n  ...\n  401  class XMLConverter(PDFConverter):\n  402  \n  403:     def __init__(self, rsrcmgr, outfp, codec='utf-8', pageno=1, laparams=None, outdir=None):\n  404:         PDFConverter.__init__(self, rsrcmgr, outfp, codec=codec, pageno=pageno, laparams=laparams)\n  405          self.outdir = outdir\n  406          self.write_header()\n  ...\n  408  \n  409      def write_header(self):\n  410:         self.outfp.write('<?xml version=\"1.0\" encoding=\"%s\" ?>\\n' % self.codec)\n  411          self.outfp.write('<pages>\\n')\n  412          return\n  ...\n  417      \n  418      def write_text(self, text):\n  419:         self.outfp.write(enc(text, self.codec))\n  420          return\n  421  \n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\pdfminer\\encodingdb.py:\n    3  import re\n    4  from psparser import PSLiteral\n    5: from glyphlist import glyphname2unicode\n    6  from latin_enc import ENCODING\n    7  \n    8  \n    9: ##  name2unicode\n   10  ##\n   11  STRIP_NAME = re.compile(r'[0-9]+')\n   12: def name2unicode(name):\n   13:     \"\"\"Converts Adobe glyph names to Unicode numbers.\"\"\"\n   14:     if name in glyphname2unicode:\n   15:         return glyphname2unicode[name]\n   16      m = STRIP_NAME.search(name)\n   17      if not m: raise KeyError(name)\n   ..\n   23  class EncodingDB(object):\n   24  \n   25:     std2unicode = {}\n   26:     mac2unicode = {}\n   27:     win2unicode = {}\n   28:     pdf2unicode = {}\n   29      for (name,std,mac,win,pdf) in ENCODING:\n   30:         c = name2unicode(name)\n   31:         if std: std2unicode[std] = c\n   32:         if mac: mac2unicode[mac] = c\n   33:         if win: win2unicode[win] = c\n   34:         if pdf: pdf2unicode[pdf] = c\n   35  \n   36      encodings = {\n   37:       'StandardEncoding': std2unicode,\n   38:       'MacRomanEncoding': mac2unicode,\n   39:       'WinAnsiEncoding': win2unicode,\n   40:       'PDFDocEncoding': pdf2unicode,\n   41        }\n   42  \n   43      @classmethod\n   44      def get_encoding(klass, name, diff=None):\n   45:         cid2unicode = klass.encodings.get(name, klass.std2unicode)\n   46          if diff:\n   47:             cid2unicode = cid2unicode.copy()\n   48              cid = 0\n   49              for x in diff:\n   ..\n   52                  elif isinstance(x, PSLiteral):\n   53                      try:\n   54:                         cid2unicode[cid] = name2unicode(x.name)\n   55                      except KeyError:\n   56                          pass\n   57                      cid += 1\n   58:         return cid2unicode\n   59  \n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\pdfminer\\glyphlist.py:\n    1  #!/usr/bin/env python2\n    2  \n    3: \"\"\" Mappings from Adobe glyph names to Unicode characters.\n    4  \n    5  In some CMap tables, Adobe glyph names are used for specifying\n    6: Unicode characters instead of using decimal/hex character code.\n    7  \n    8  The following data was taken by\n    .\n   48  # Date:          September 20, 2002\n   49  #\n   50: # See http://partners.adobe.com/asn/developer/typeforum/unicodegn.html\n   51  #\n   52  # Format: Semicolon-delimited fields:\n   53  #            (1) glyph name\n   54: #            (2) Unicode scalar value\n   55  \n   56: glyphname2unicode = {\n   57   'A': u'\\u0041',\n   58   'AE': u'\\u00C6',\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\pdfminer\\lzw.py:\n    7  \n    8  \n    9: ##  LZWDecoder\n   10  ##\n   11: class LZWDecoder(object):\n   12  \n   13      debug = 0\n   ..\n   46          return v\n   47  \n   48:     def feed(self, code):\n   49          x = ''\n   50:         if code == 256:\n   51              self.table = [ chr(c) for c in xrange(256) ] # 0-255\n   52              self.table.append(None) # 256\n   ..\n   54              self.prevbuf = ''\n   55              self.nbits = 9\n   56:         elif code == 257:\n   57              pass\n   58          elif not self.prevbuf:\n   59:             x = self.prevbuf = self.table[code]\n   60          else:\n   61:             if code < len(self.table):\n   62:                 x = self.table[code]\n   63                  self.table.append(self.prevbuf+x[0])\n   64              else:\n   65                  self.table.append(self.prevbuf+self.prevbuf[0])\n   66:                 x = self.table[code]\n   67              l = len(self.table)\n   68              if l == 511:\n   ..\n   78          while 1:\n   79              try:\n   80:                 code = self.readbits(self.nbits)\n   81              except EOFError:\n   82                  break\n   83:             x = self.feed(code)\n   84              yield x\n   85              if self.debug:\n   86:                 print >>sys.stderr, ('nbits=%d, code=%d, output=%r, table=%r' %\n   87:                                      (self.nbits, code, x, self.table[258:]))\n   88          return\n   89  \n   90: # lzwdecode\n   91: def lzwdecode(data):\n   92      \"\"\"\n   93:     >>> lzwdecode('\\x80\\x0b\\x60\\x50\\x22\\x0c\\x0c\\x85\\x01')\n   94      '\\x2d\\x2d\\x2d\\x2d\\x2d\\x41\\x2d\\x2d\\x2d\\x42'\n   95      \"\"\"\n   96      fp = StringIO(data)\n   97:     return ''.join(LZWDecoder(fp).run())\n   98  \n   99  if __name__ == '__main__':\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\pdfminer\\pdfdevice.py:\n    3  from utils import mult_matrix, translate_matrix\n    4  from utils import enc, bbox2str\n    5: from pdffont import PDFUnicodeNotDefined\n    6  \n    7  \n    .\n   84                  needcharspace = True\n   85              else:\n   86:                 for cid in font.decode(obj):\n   87                      if needcharspace:\n   88                          x += charspace\n   ..\n  102                  needcharspace = True\n  103              else:\n  104:                 for cid in font.decode(obj):\n  105                      if needcharspace:\n  106                          y += charspace\n  ...\n  120  class TagExtractor(PDFDevice):\n  121  \n  122:     def __init__(self, rsrcmgr, outfp, codec='utf-8', debug=0):\n  123          PDFDevice.__init__(self, rsrcmgr)\n  124          self.outfp = outfp\n  125:         self.codec = codec\n  126          self.debug = debug\n  127          self.pageno = 0\n  ...\n  134          for obj in seq:\n  135              if not isinstance(obj, str): continue\n  136:             chars = font.decode(obj)\n  137              for cid in chars:\n  138                  try:\n  139                      char = font.to_unichr(cid)\n  140                      text += char\n  141:                 except PDFUnicodeNotDefined:\n  142                      pass\n  143:         self.outfp.write(enc(text, self.codec))\n  144          return\n  145  \n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\pdfminer\\pdffont.py:\n    6  except ImportError:\n    7      from StringIO import StringIO\n    8: from cmapdb import CMapDB, CMapParser, FileUnicodeMap, CMap\n    9: from encodingdb import EncodingDB, name2unicode\n   10  from psparser import PSStackParser\n   11  from psparser import PSSyntaxError, PSEOF\n   ..\n   89      def __init__(self, data):\n   90          PSStackParser.__init__(self, data)\n   91:         self._cid2unicode = {}\n   92          return\n   93  \n   ..\n   99                  break\n  100              try:\n  101:                 self._cid2unicode[cid] = name2unicode(name)\n  102              except KeyError:\n  103                  pass\n  104:         return self._cid2unicode\n  105      \n  106      def do_keyword(self, pos, token):\n  ...\n  291          self.nglyphs = len(self.charstring)\n  292          # Encodings\n  293:         self.code2gid = {}\n  294:         self.gid2code = {}\n  295          self.fp.seek(encoding_pos)\n  296          format = self.fp.read(1)\n  ...\n  298              # Format 0\n  299              (n,) = struct.unpack('B', self.fp.read(1))\n  300:             for (code,gid) in enumerate(struct.unpack('B'*n, self.fp.read(n))):\n  301:                 self.code2gid[code] = gid\n  302:                 self.gid2code[gid] = code\n  303          elif format == '\\x01':\n  304              # Format 1\n  305              (n,) = struct.unpack('B', self.fp.read(1))\n  306:             code = 0\n  307              for i in xrange(n):\n  308                  (first,nleft) = struct.unpack('BB', self.fp.read(2))\n  309                  for gid in xrange(first,first+nleft+1):\n  310:                     self.code2gid[code] = gid\n  311:                     self.gid2code[gid] = code\n  312:                     code += 1\n  313          else:\n  314              raise ValueError('unsupported encoding format: %r' % format)\n  ...\n  342          else:\n  343              raise ValueError('unsupported charset format: %r' % format)\n  344:         #print self.code2gid\n  345          #print self.name2gid\n  346          #assert 0\n  ...\n  370          return\n  371  \n  372:     def create_unicode_map(self):\n  373          if 'cmap' not in self.tables:\n  374              raise TrueTypeFont.CMapNotFound\n  ...\n  395                  hdrs = []\n  396                  for i in xrange(nhdrs):\n  397:                     (firstcode,entcount,delta,offset) = struct.unpack('>HHhH', fp.read(8))\n  398:                     hdrs.append((i,firstcode,entcount,delta,fp.tell()-2+offset))\n  399:                 for (i,firstcode,entcount,delta,pos) in hdrs:\n  400                      if not entcount: continue\n  401:                     first = firstcode + (firstbytes[i] << 8)\n  402                      fp.seek(pos)\n  403                      for c in xrange(entcount):\n  ...\n  425              else:\n  426                  assert 0\n  427:         # create unicode map\n  428:         unicode_map = FileUnicodeMap()\n  429          for (char,gid) in char2gid.iteritems():\n  430:             unicode_map.add_cid2unichr(gid, char)\n  431:         return unicode_map\n  432  \n  433  \n  ...\n  436  \n  437  class PDFFontError(PDFException): pass\n  438: class PDFUnicodeNotDefined(PDFFontError): pass\n  439  \n  440  LITERAL_STANDARD_ENCODING = LIT('StandardEncoding')\n  ...\n  470          return False\n  471  \n  472:     def decode(self, bytes):\n  473          return map(ord, bytes)\n  474  \n  ...\n  496  \n  497      def string_width(self, s):\n  498:         return sum( self.char_width(cid) for cid in self.decode(s) )\n  499  \n  500  \n  ...\n  513              name = literal_name(encoding.get('BaseEncoding', LITERAL_STANDARD_ENCODING))\n  514              diff = list_value(encoding.get('Differences', None))\n  515:             self.cid2unicode = EncodingDB.get_encoding(name, diff)\n  516          else:\n  517:             self.cid2unicode = EncodingDB.get_encoding(literal_name(encoding))\n  518:         self.unicode_map = None\n  519:         if 'ToUnicode' in spec:\n  520:             strm = stream_value(spec['ToUnicode'])\n  521:             self.unicode_map = FileUnicodeMap()\n  522:             CMapParser(self.unicode_map, StringIO(strm.get_data())).run()\n  523          PDFFont.__init__(self, descriptor, widths)\n  524          return\n  525  \n  526      def to_unichr(self, cid):\n  527:         if self.unicode_map:\n  528              try:\n  529:                 return self.unicode_map.get_unichr(cid)\n  530              except KeyError:\n  531                  pass\n  532          try:\n  533:             return self.cid2unicode[cid]\n  534          except KeyError:\n  535:             raise PDFUnicodeNotDefined(None, cid)\n  536  \n  537  # PDFType1Font\n  ...\n  560              data = self.fontfile.get_data()[:length1]\n  561              parser = Type1FontHeaderParser(StringIO(data))\n  562:             self.cid2unicode = parser.get_encoding()\n  563          return\n  564  \n  ...\n  631              ttf = TrueTypeFont(self.basefont,\n  632                                 StringIO(self.fontfile.get_data()))\n  633:         self.unicode_map = None\n  634:         if 'ToUnicode' in spec:\n  635:             strm = stream_value(spec['ToUnicode'])\n  636:             self.unicode_map = FileUnicodeMap()\n  637:             CMapParser(self.unicode_map, StringIO(strm.get_data())).run()\n  638          elif self.cidcoding == 'Adobe-Identity':\n  639              if ttf:\n  640                  try:\n  641:                     self.unicode_map = ttf.create_unicode_map()\n  642                  except TrueTypeFont.CMapNotFound:\n  643                      pass\n  644          else:\n  645              try:\n  646:                 self.unicode_map = CMapDB.get_unicode_map(self.cidcoding, self.cmap.is_vertical())\n  647              except CMapDB.CMapNotFound, e:\n  648                  pass\n  ...\n  675          return True\n  676  \n  677:     def decode(self, bytes):\n  678:         return self.cmap.decode(bytes)\n  679  \n  680      def char_disp(self, cid):\n  ...\n  684      def to_unichr(self, cid):\n  685          try:\n  686:             if not self.unicode_map: raise KeyError(cid)\n  687:             return self.unicode_map.get_unichr(cid)\n  688          except KeyError:\n  689:             raise PDFUnicodeNotDefined(self.cidcoding, cid)\n  690  \n  691  \n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\pdfminer\\pdfinterp.py:\n  188                  assert dfonts\n  189                  subspec = dict_value(dfonts[0]).copy()\n  190:                 for k in ('Encoding', 'ToUnicode'):\n  191                      if k in spec:\n  192                          subspec[k] = resolve1(spec[k])\n  ...\n  787                  if hasattr(self, method):\n  788                      func = getattr(self, method)\n  789:                     nargs = func.func_code.co_argcount-1\n  790                      if nargs:\n  791                          args = self.pop(nargs)\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\pdfminer\\pdfparser.py:\n   22  from arcfour import Arcfour\n   23  from utils import choplist, nunpack\n   24: from utils import decode_text, ObjIdRange\n   25  \n   26  \n   ..\n  526              if 'Title' in entry:\n  527                  if 'A' in entry or 'Dest' in entry:\n  528:                     title = decode_text(str_value(entry['Title']))\n  529                      dest = entry.get('Dest')\n  530                      action = entry.get('A')\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\pdfminer\\pdftypes.py:\n    2  import sys\n    3  import zlib\n    4: from lzw import lzwdecode\n    5: from ascii85 import ascii85decode, asciihexdecode\n    6: from runlength import rldecode\n    7  from psparser import PSException, PSObject\n    8  from psparser import LIT, KWD, STRICT\n    .\n   11  \n   12  # Abbreviation of Filter names in PDF 4.8.6. \"Inline Images\"\n   13: LITERALS_FLATE_DECODE = (LIT('FlateDecode'), LIT('Fl'))\n   14: LITERALS_LZW_DECODE = (LIT('LZWDecode'), LIT('LZW'))\n   15: LITERALS_ASCII85_DECODE = (LIT('ASCII85Decode'), LIT('A85'))\n   16: LITERALS_ASCIIHEX_DECODE = (LIT('ASCIIHexDecode'), LIT('AHx'))\n   17: LITERALS_RUNLENGTH_DECODE = (LIT('RunLengthDecode'), LIT('RL'))\n   18: LITERALS_CCITTFAX_DECODE = (LIT('CCITTFaxDecode'), LIT('CCF'))\n   19: LITERALS_DCT_DECODE = (LIT('DCTDecode'), LIT('DCT'))\n   20  \n   21  \n   ..\n  194          return [ filters ]\n  195  \n  196:     def decode(self):\n  197          assert self.data is None and self.rawdata != None\n  198          data = self.rawdata\n  ...\n  206              return\n  207          for f in filters:\n  208:             if f in LITERALS_FLATE_DECODE:\n  209                  # will get errors if the document is encrypted.\n  210                  try:\n  ...\n  214                          raise PDFException('Invalid zlib bytes: %r, %r' % (e, data))\n  215                      data = ''\n  216:             elif f in LITERALS_LZW_DECODE:\n  217:                 data = lzwdecode(data)\n  218:             elif f in LITERALS_ASCII85_DECODE:\n  219:                 data = ascii85decode(data)\n  220:             elif f in LITERALS_ASCIIHEX_DECODE:\n  221:                 data = asciihexdecode(data)\n  222:             elif f in LITERALS_RUNLENGTH_DECODE:\n  223:                 data = rldecode(data)\n  224:             elif f in LITERALS_CCITTFAX_DECODE:\n  225:                 #data = ccittfaxdecode(data)\n  226                  raise PDFNotImplementedError('Unsupported filter: %r' % f)\n  227              elif f == LITERAL_CRYPT:\n  ...\n  231                  raise PDFNotImplementedError('Unsupported filter: %r' % f)\n  232              # apply predictors\n  233:             params = self.get_any(('DP', 'DecodeParms', 'FDecodeParms'), {})\n  234              if 'Predictor' in params and 'Columns' in params:\n  235                  pred = int_value(params['Predictor'])\n  ...\n  254      def get_data(self):\n  255          if self.data is None:\n  256:             self.decode()\n  257          return self.data\n  258  \n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\pdfminer\\rijndael.py:\n    3  \"\"\" Python implementation of Rijndael encryption algorithm.\n    4  \n    5: This code is in the public domain.\n    6  \n    7: This code is based on a public domain C implementation\n    8  by Philip J. Erdelsky:\n    9    http://www.efgh.com/software/rijndael.htm\n   ..\n 1035  \n 1036      \"\"\"\n 1037:     >>> key = '00010203050607080a0b0c0d0f101112'.decode('hex')\n 1038:     >>> ciphertext = 'd8f532538289ef7d06b506a4fd5be9c9'.decode('hex')\n 1039:     >>> RijndaelDecryptor(key, 128).decrypt(ciphertext).encode('hex')\n 1040      '506812a45f08c889b97f5980038b8359'\n 1041      \"\"\"\n ....\n 1056  \n 1057      \"\"\"\n 1058:     >>> key = '00010203050607080a0b0c0d0f101112'.decode('hex')\n 1059:     >>> plaintext = '506812a45f08c889b97f5980038b8359'.decode('hex')\n 1060:     >>> RijndaelEncryptor(key, 128).encrypt(plaintext).encode('hex')\n 1061      'd8f532538289ef7d06b506a4fd5be9c9'\n 1062      \"\"\"\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\pdfminer\\runlength.py:\n    1  #!/usr/bin/env python2\n    2  #\n    3: # RunLength decoder (Adobe version) implementation based on PDF Reference\n    4  # version 1.4 section 3.3.4.\n    5  #\n    .\n    9  import sys\n   10  \n   11: def rldecode(data):\n   12      \"\"\"\n   13:     RunLength decoder (Adobe version) implementation based on PDF Reference\n   14      version 1.4 section 3.3.4:\n   15:         The RunLengthDecode filter decodes data that has been encoded in a\n   16:         simple byte-oriented format based on run length. The encoded data\n   17          is a sequence of runs, where each run consists of a length byte\n   18          followed by 1 to 128 bytes of data. If the length byte is in the\n   ..\n   23          denotes EOD.\n   24      >>> s = \"\\x05123456\\xfa7\\x04abcde\\x80junk\"\n   25:     >>> rldecode(s)\n   26      '1234567777777abcde'\n   27      \"\"\"\n   28:     decoded = []\n   29      i=0\n   30      while i < len(data):\n   ..\n   36              run = data[i+1:(i+1)+(length+1)]\n   37              #print \"length=%d, run=%s\" % (length+1,run)\n   38:             decoded.append(run)\n   39              i = (i+1) + (length+1)\n   40          if length > 128:\n   41              run = data[i+1]*(257-length)\n   42              #print \"length=%d, run=%s\" % (257-length,run)\n   43:             decoded.append(run)\n   44              i = (i+1) + 1\n   45:     return ''.join(decoded)\n   46  \n   47  \n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\pdfminer\\utils.py:\n  116          raise TypeError('invalid length: %d' % l)\n  117  \n  118: # decode_text\n  119  PDFDocEncoding = ''.join( unichr(x) for x in (\n  120    0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007,\n  ...\n  151    0x00f8, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x00fd, 0x00fe, 0x00ff,\n  152  ))\n  153: def decode_text(s):\n  154:     \"\"\"Decodes a PDFDocEncoding string to Unicode.\"\"\"\n  155      if s.startswith('\\xfe\\xff'):\n  156:         return unicode(s[2:], 'utf-16be', 'ignore')\n  157      else:\n  158          return ''.join( PDFDocEncoding[ord(c)] for c in s )\n  159  \n  160  # enc\n  161: def enc(x, codec='ascii'):\n  162:     \"\"\"Encodes a string for SGML/XML/HTML\"\"\"\n  163      x = x.replace('&','&amp;').replace('>','&gt;').replace('<','&lt;').replace('\"','&quot;')\n  164:     return x.encode(codec, 'xmlcharrefreplace')\n  165  \n  166  def bbox2str((x0,y0,x1,y1)):\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\tools\\conv_cmap.py:\n    5  import cPickle as pickle\n    6  \n    7: def process_cid2code(fp, check_codecs=[]):\n    8  \n    9      def get_canonicals(name):\n   ..\n   15              return (name+'-H', name+'-V')\n   16  \n   17:     def get_unichr(codes):\n   18          # determine the \"most popular\" candidate.\n   19          d = {}\n   20:         for code in codes:\n   21:             char = unicode(code, 'utf-8')\n   22              if char not in d:\n   23                  d[char] = 0\n   24:             for codec in check_codecs:\n   25                  try:\n   26:                     char.encode(codec, 'strict')\n   27                      d[char] += 1\n   28:                 except UnicodeError:\n   29                      pass\n   30          chars = sorted(d.keys(), key=lambda char:d[char], reverse=True)\n   31          return chars[0]\n   32  \n   33:     def put(dmap, code, cid, force=False):\n   34:         for b in code[:-1]:\n   35              b = ord(b)\n   36              if b in dmap:\n   ..\n   40                  dmap[b] = d\n   41                  dmap = d\n   42:         b = ord(code[-1])\n   43          if force or ((b not in dmap) or dmap[b] == cid):\n   44              dmap[b] = cid\n   ..\n   46  \n   47      names = []\n   48:     code2cid = {} # {'cmapname': ...}\n   49      is_vertical = {}\n   50      cid2unichr_h = {} # {cid: unichr}\n   ..\n   63              if x == '*': continue\n   64              (hmapname, vmapname) = get_canonicals(name)\n   65:             if hmapname in code2cid:\n   66:                 hmap = code2cid[hmapname]\n   67              else:\n   68                  hmap = {}\n   69:                 code2cid[hmapname] = hmap\n   70              vmap = None\n   71              if vmapname:\n   72                  is_vertical[vmapname] = True\n   73:                 if vmapname in code2cid:\n   74:                     vmap = code2cid[vmapname]\n   75                  else:\n   76                      vmap = {}\n   77:                     code2cid[vmapname] = vmap\n   78:             hcodes = []\n   79:             vcodes = []\n   80:             for code in x.split(','):\n   81:                 vertical = code.endswith('v')\n   82                  if vertical:\n   83:                     code = code[:-1]\n   84                  try:\n   85:                     code = code.decode('hex')\n   86                  except:\n   87:                     code = chr(int(code, 16))\n   88                  if vertical:\n   89:                     vcodes.append(code)\n   90                  else:\n   91:                     hcodes.append(code)\n   92:             if vcodes:\n   93                  assert vmap is not None\n   94:                 for code in vcodes:\n   95:                     put(vmap, code, cid, True)\n   96:                 for code in hcodes:\n   97:                     put(hmap, code, cid, True)\n   98                  if name.endswith('-UTF8'):\n   99:                     if hcodes:\n  100:                         cid2unichr_h[cid] = get_unichr(hcodes)\n  101:                     if vcodes:\n  102:                         cid2unichr_v[cid] = get_unichr(vcodes)\n  103              else:\n  104:                 for code in hcodes:\n  105:                     put(hmap, code, cid)\n  106:                     put(vmap, code, cid)\n  107:                 if name.endswith('-UTF8') and hcodes:\n  108:                     code = get_unichr(hcodes)\n  109                      if cid not in cid2unichr_h:\n  110:                         cid2unichr_h[cid] = code\n  111                      if cid not in cid2unichr_v:\n  112:                         cid2unichr_v[cid] = code\n  113  \n  114:     return (code2cid, is_vertical, cid2unichr_h, cid2unichr_v)\n  115  \n  116  # main\n  ...\n  118  \n  119      def usage():\n  120:         print 'usage: %s output_dir regname cid2code.txt codecs ...' % argv[0]\n  121          return 100\n  122      \n  ...\n  124      if len(args) < 3: return usage()\n  125      (outdir, regname, src) = args[:3]\n  126:     check_codecs = args[3:]\n  127  \n  128      print >>sys.stderr, 'reading %r...' % src\n  129      fp = file(src)\n  130:     (code2cid, is_vertical, cid2unichr_h, cid2unichr_v) = process_cid2code(fp, check_codecs)\n  131      fp.close()\n  132  \n  133:     for (name, cmap) in code2cid.iteritems():\n  134          fname = '%s.pickle.gz' % name\n  135          print >>sys.stderr, 'writing %r...' % fname\n  ...\n  137          data = dict(\n  138              IS_VERTICAL=is_vertical.get(name, False),\n  139:             CODE2CID=cmap,\n  140          )\n  141          fp.write(pickle.dumps(data))\n  142          fp.close()\n  143  \n  144:     fname = 'to-unicode-%s.pickle.gz' % regname\n  145      print >>sys.stderr, 'writing %r...' % fname\n  146      fp = gzip.open(os.path.join(outdir, fname), 'wb')\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\tools\\conv_glyphlist.py:\n   16          if state == 0:\n   17              print\n   18:             print 'glyphname2unicode = {'\n   19              state = 1\n   20          (name,x) = line.split(';')\n   21:         codes = x.split(' ')\n   22:         print ' %r: u\\'%s\\',' % (name, ''.join( '\\\\u%s' % code for code in codes ))\n   23  \n   24  if __name__ == '__main__': sys.exit(main(sys.argv))\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\tools\\dumppdf.py:\n   19  \n   20  # dumpxml\n   21: def dumpxml(out, obj, codec=None):\n   22      if obj is None:\n   23          out.write('<null />')\n   ..\n   47  \n   48      if isinstance(obj, PDFStream):\n   49:         if codec == 'raw':\n   50              out.write(obj.get_rawdata())\n   51:         elif codec == 'binary':\n   52              out.write(obj.get_data())\n   53          else:\n   ..\n   55              dumpxml(out, obj.attrs)\n   56              out.write('\\n</props>\\n')\n   57:             if codec == 'text':\n   58                  data = obj.get_data()\n   59                  out.write('<data size=\"%d\">%s</data>\\n' % (len(data), e(data)))\n   ..\n   88  \n   89  # dumpallobjs\n   90: def dumpallobjs(out, doc, codec=None):\n   91      out.write('<pdf>')\n   92      for xref in doc.xrefs:\n   ..\n   96                  if obj is None: continue\n   97                  out.write('<object id=\"%d\">\\n' % objid)\n   98:                 dumpxml(out, obj, codec=codec)\n   99                  out.write('\\n</object>\\n\\n')\n  100              except:\n  ...\n  106  # dumpoutline\n  107  def dumpoutline(outfp, fname, objids, pagenos, password='',\n  108:                 dumpall=False, codec=None):\n  109      doc = PDFDocument()\n  110      fp = file(fname, 'rb')\n  ...\n  137                          dest = resolve_dest(action['D'])\n  138                          pageno = pages[dest[0].objid]\n  139:             s = e(title).encode('utf-8', 'xmlcharrefreplace')\n  140              outfp.write('<outline level=\"%r\" title=\"%s\">\\n' % (level, s))\n  141              if dest is not None:\n  ...\n  155  # dumppdf\n  156  def dumppdf(outfp, fname, objids, pagenos, password='',\n  157:             dumpall=False, codec=None):\n  158      doc = PDFDocument()\n  159      fp = file(fname, 'rb')\n  ...\n  165          for objid in objids:\n  166              obj = doc.getobj(objid)\n  167:             dumpxml(outfp, obj, codec=codec)\n  168      if pagenos:\n  169          for (pageno,page) in enumerate(doc.get_pages()):\n  170              if pageno in pagenos:\n  171:                 if codec:\n  172                      for obj in page.contents:\n  173                          obj = stream_value(obj)\n  174:                         dumpxml(outfp, obj, codec=codec)\n  175                  else:\n  176                      dumpxml(outfp, page.attrs)\n  177      if dumpall:\n  178:         dumpallobjs(outfp, doc, codec=codec)\n  179      if (not objids) and (not pagenos) and (not dumpall):\n  180          dumptrailers(outfp, doc)\n  181      fp.close()\n  182:     if codec not in ('raw','binary'):\n  183          outfp.write('\\n')\n  184      return\n  ...\n  199      objids = []\n  200      pagenos = set()\n  201:     codec = None\n  202      password = ''\n  203      dumpall = False\n  ...\n  210          elif k == '-P': password = v\n  211          elif k == '-a': dumpall = True\n  212:         elif k == '-r': codec = 'raw'\n  213:         elif k == '-b': codec = 'binary'\n  214:         elif k == '-t': codec = 'text'\n  215          elif k == '-T': proc = dumpoutline\n  216          elif k == '-o': outfp = file(v, 'wb')\n  ...\n  221      for fname in args:\n  222          proc(outfp, fname, objids, pagenos, password=password,\n  223:              dumpall=dumpall, codec=codec)\n  224      return\n  225  \n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\tools\\latin2ascii.py:\n  113      import getopt, fileinput\n  114      def usage():\n  115:         print 'usage: %s [-c codec] file ...' % argv[0]\n  116          return 100\n  117      try:\n  ...\n  120          return usage()\n  121      if not args: return usage()\n  122:     codec = 'utf-8'\n  123      for (k, v) in opts:\n  124:         if k == '-c': codec = v\n  125      for line in fileinput.input(args):\n  126:         line = latin2ascii(unicode(line, codec, 'ignore'))\n  127:         sys.stdout.write(line.encode('ascii', 'replace'))\n  128      return\n  129  \n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\tools\\pdf2txt.py:\n   14          print ('usage: %s [-d] [-p pagenos] [-m maxpages] [-P password] [-o output] [-C] '\n   15                 '[-n] [-A] [-V] [-M char_margin] [-L line_margin] [-W word_margin] [-F boxes_flow] '\n   16:                '[-Y layout_mode] [-O output_dir] [-t text|html|xml|tag] [-c codec] [-s scale] file ...' % argv[0])\n   17          return 100\n   18      try:\n   ..\n   32      outdir = None\n   33      layoutmode = 'normal'\n   34:     codec = 'utf-8'\n   35      pageno = 1\n   36      scale = 1\n   ..\n   55          elif k == '-O': outdir = v\n   56          elif k == '-t': outtype = v\n   57:         elif k == '-c': codec = v\n   58          elif k == '-s': scale = float(v)\n   59      #\n   ..\n   80          outfp = sys.stdout\n   81      if outtype == 'text':\n   82:         device = TextConverter(rsrcmgr, outfp, codec=codec, laparams=laparams)\n   83      elif outtype == 'xml':\n   84:         device = XMLConverter(rsrcmgr, outfp, codec=codec, laparams=laparams, outdir=outdir)\n   85      elif outtype == 'html':\n   86:         device = HTMLConverter(rsrcmgr, outfp, codec=codec, scale=scale,\n   87                                 layoutmode=layoutmode, laparams=laparams, outdir=outdir)\n   88      elif outtype == 'tag':\n   89:         device = TagExtractor(rsrcmgr, outfp, codec=codec)\n   90      else:\n   91          return usage()\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\model\\show.py:\n   11      VERBOSE = False;\n   12      \n   13:     def __init__(self, code, club, locations, dates):\n   14:         self.code = code;\n   15          self.clubs = set();\n   16          self.addClub(club);\n   ..\n   35          [clubList.append(c) for c in self.clubs]\n   36          [dateList.append(d) for d in self.dates]\n   37:         return {'id':self.code, 'clubs':json.loads(json.dumps(clubList)), 'locations':str(self.locations), 'dates':json.loads(json.dumps(dateTimes))}\n   38      def __str__(self):\n   39          return str(self.clubs) + \"\\n\\t, dates:\"  + str(self.dates) + \"\\n\\t, locations:\"  + str(self.locations) + ', clubs:' + str(self.clubs);\n   ..\n   66  \n   67      @property\n   68:     def showCode(self):\n   69:         return self._programcode;\n   70  \n   71      @parsedFilePath.setter\n   ..\n  139      \n  140      def __eq__(self, other):\n  141:         return self.code == other.code;\n  142  \n  143      def __hash__(self):\n  144          #This is not portable, or persistable, but it's fine for our case\n  145:         return hash(self.code);\n  146  \n  147  \n\n846 matches across 49 files\n\n\nSearching 75 files for \".code =\" (regex)\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\demo.py:\n   45          self._club = club;\n   46          self._pagelink = pageLink;\n   47:         self._programcode = programcode;\n   48          self._location = None;\n   49          self._date = None;\n   ..\n  128                  print(\"download died: \" + self._pagelink)\n  129                  return False;\n  130:             #self._programcode = \"PPTO1\";\n  131              pdfName = self.programName; \n  132              url = baseUrl + self._pdfLink;\n  ...\n  183          link = anchor['href']\n  184          club = pullKennelClub(anchor);\n  185:         code = pullShowCode(link)\n  186          if club and code:\n  187              show = Show(club, baseUrl+link, code)\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\driver.py:\n  146              doParseAndClean(show);\n  147              print(\"programName: \" + show.programName)\n  148:             if show.showCode == \"KTDC1\":\n  149                  print(\"found KTDC1\")\n  150                  json = doRunGrammar(show);\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\show.py:\n   17          self._club = club;\n   18          self._pagelink = pageLink;\n   19:         self._programcode = programcode;\n   20          self._location = None;\n   21          self._date = None;\n   ..\n   88                  print(\"download died: \" + self._pagelink)\n   89                  return False;\n   90:             #self._programcode = \"PPTO1\";\n   91              pdfName = self.programName; \n   92              url = config.Onofrio.pdfUrl(self._pdfLink)            \n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\showscraper.py:\n   48              location = self._parseLocation(pool);\n   49              #self._hasProgram = self._checkIfProgram(pool);\n   50:             code = self._pullShowCode(pool);\n   51              if self.VERBOSE:\n   52                  print('code:' + str(code));\n   ..\n  163                  print('_pullShowCode found the program anchor');\n  164                  self.pdfLink = results[0]['href'];\n  165:                 code = re.search(\"(?P<name>(?P<code>[A-Z]+[0-9])\\JP.pdf)\", self.pdfLink).group('code')\n  166                  return code;\n  167              else:\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\util.py:\n   11  class RegexPatternDef(object):\n   12  	KENNEL_CLUB = \"([a-zA-Z-]+(?: [a-zA-Z-,]+)*)\";\n   13: 	SHOW_CODE = \"=(?P<link>[a-zA-Z]+[0-9])\";\n   14  	WEEK_DAY = \"(?:Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday)\";\n   15  	MONTH = \"(?:January|February|March|April|May|June|July|August|September|October|November|December)\";\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\build\\lib\\pdfminer\\ascii85.py:\n   69      'p'\n   70      \"\"\"\n   71:     decode = (lambda hx: chr(int(hx, 16)))\n   72      out = map(decode, hex_re.findall(data))\n   73      m = trail_re.search(data)\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\build\\lib\\pdfminer\\cmapdb.py:\n   75          if code2cid is None:\n   76              code2cid = self.code2cid\n   77:             code = ()\n   78          for (k,v) in sorted(code2cid.iteritems()):\n   79              c = code+(k,)\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\build\\lib\\pdfminer\\encodingdb.py:\n   23  class EncodingDB(object):\n   24  \n   25:     std2unicode = {}\n   26:     mac2unicode = {}\n   27:     win2unicode = {}\n   28:     pdf2unicode = {}\n   29      for (name,std,mac,win,pdf) in ENCODING:\n   30          c = name2unicode(name)\n   ..\n   43      @classmethod\n   44      def get_encoding(klass, name, diff=None):\n   45:         cid2unicode = klass.encodings.get(name, klass.std2unicode)\n   46          if diff:\n   47:             cid2unicode = cid2unicode.copy()\n   48              cid = 0\n   49              for x in diff:\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\build\\lib\\pdfminer\\glyphlist.py:\n   54  #            (2) Unicode scalar value\n   55  \n   56: glyphname2unicode = {\n   57   'A': u'\\u0041',\n   58   'AE': u'\\u00C6',\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\build\\lib\\pdfminer\\lzw.py:\n   48      def feed(self, code):\n   49          x = ''\n   50:         if code == 256:\n   51              self.table = [ chr(c) for c in xrange(256) ] # 0-255\n   52              self.table.append(None) # 256\n   ..\n   54              self.prevbuf = ''\n   55              self.nbits = 9\n   56:         elif code == 257:\n   57              pass\n   58          elif not self.prevbuf:\n   ..\n   78          while 1:\n   79              try:\n   80:                 code = self.readbits(self.nbits)\n   81              except EOFError:\n   82                  break\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\build\\lib\\pdfminer\\pdffont.py:\n   89      def __init__(self, data):\n   90          PSStackParser.__init__(self, data)\n   91:         self._cid2unicode = {}\n   92          return\n   93  \n   ..\n  292          # Encodings\n  293          self.code2gid = {}\n  294:         self.gid2code = {}\n  295          self.fp.seek(encoding_pos)\n  296          format = self.fp.read(1)\n  ...\n  304              # Format 1\n  305              (n,) = struct.unpack('B', self.fp.read(1))\n  306:             code = 0\n  307              for i in xrange(n):\n  308                  (first,nleft) = struct.unpack('BB', self.fp.read(2))\n  ...\n  513              name = literal_name(encoding.get('BaseEncoding', LITERAL_STANDARD_ENCODING))\n  514              diff = list_value(encoding.get('Differences', None))\n  515:             self.cid2unicode = EncodingDB.get_encoding(name, diff)\n  516          else:\n  517:             self.cid2unicode = EncodingDB.get_encoding(literal_name(encoding))\n  518          self.unicode_map = None\n  519          if 'ToUnicode' in spec:\n  ...\n  560              data = self.fontfile.get_data()[:length1]\n  561              parser = Type1FontHeaderParser(StringIO(data))\n  562:             self.cid2unicode = parser.get_encoding()\n  563          return\n  564  \n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\build\\lib\\pdfminer\\pdftypes.py:\n   11  \n   12  # Abbreviation of Filter names in PDF 4.8.6. \"Inline Images\"\n   13: LITERALS_FLATE_DECODE = (LIT('FlateDecode'), LIT('Fl'))\n   14: LITERALS_LZW_DECODE = (LIT('LZWDecode'), LIT('LZW'))\n   15: LITERALS_ASCII85_DECODE = (LIT('ASCII85Decode'), LIT('A85'))\n   16: LITERALS_ASCIIHEX_DECODE = (LIT('ASCIIHexDecode'), LIT('AHx'))\n   17: LITERALS_RUNLENGTH_DECODE = (LIT('RunLengthDecode'), LIT('RL'))\n   18: LITERALS_CCITTFAX_DECODE = (LIT('CCITTFaxDecode'), LIT('CCF'))\n   19: LITERALS_DCT_DECODE = (LIT('DCTDecode'), LIT('DCT'))\n   20  \n   21  \n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\pdfminer\\ascii85.py:\n   69      'p'\n   70      \"\"\"\n   71:     decode = (lambda hx: chr(int(hx, 16)))\n   72      out = map(decode, hex_re.findall(data))\n   73      m = trail_re.search(data)\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\pdfminer\\cmapdb.py:\n   75          if code2cid is None:\n   76              code2cid = self.code2cid\n   77:             code = ()\n   78          for (k,v) in sorted(code2cid.iteritems()):\n   79              c = code+(k,)\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\pdfminer\\encodingdb.py:\n   23  class EncodingDB(object):\n   24  \n   25:     std2unicode = {}\n   26:     mac2unicode = {}\n   27:     win2unicode = {}\n   28:     pdf2unicode = {}\n   29      for (name,std,mac,win,pdf) in ENCODING:\n   30          c = name2unicode(name)\n   ..\n   43      @classmethod\n   44      def get_encoding(klass, name, diff=None):\n   45:         cid2unicode = klass.encodings.get(name, klass.std2unicode)\n   46          if diff:\n   47:             cid2unicode = cid2unicode.copy()\n   48              cid = 0\n   49              for x in diff:\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\pdfminer\\glyphlist.py:\n   54  #            (2) Unicode scalar value\n   55  \n   56: glyphname2unicode = {\n   57   'A': u'\\u0041',\n   58   'AE': u'\\u00C6',\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\pdfminer\\lzw.py:\n   48      def feed(self, code):\n   49          x = ''\n   50:         if code == 256:\n   51              self.table = [ chr(c) for c in xrange(256) ] # 0-255\n   52              self.table.append(None) # 256\n   ..\n   54              self.prevbuf = ''\n   55              self.nbits = 9\n   56:         elif code == 257:\n   57              pass\n   58          elif not self.prevbuf:\n   ..\n   78          while 1:\n   79              try:\n   80:                 code = self.readbits(self.nbits)\n   81              except EOFError:\n   82                  break\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\pdfminer\\pdffont.py:\n   89      def __init__(self, data):\n   90          PSStackParser.__init__(self, data)\n   91:         self._cid2unicode = {}\n   92          return\n   93  \n   ..\n  292          # Encodings\n  293          self.code2gid = {}\n  294:         self.gid2code = {}\n  295          self.fp.seek(encoding_pos)\n  296          format = self.fp.read(1)\n  ...\n  304              # Format 1\n  305              (n,) = struct.unpack('B', self.fp.read(1))\n  306:             code = 0\n  307              for i in xrange(n):\n  308                  (first,nleft) = struct.unpack('BB', self.fp.read(2))\n  ...\n  513              name = literal_name(encoding.get('BaseEncoding', LITERAL_STANDARD_ENCODING))\n  514              diff = list_value(encoding.get('Differences', None))\n  515:             self.cid2unicode = EncodingDB.get_encoding(name, diff)\n  516          else:\n  517:             self.cid2unicode = EncodingDB.get_encoding(literal_name(encoding))\n  518          self.unicode_map = None\n  519          if 'ToUnicode' in spec:\n  ...\n  560              data = self.fontfile.get_data()[:length1]\n  561              parser = Type1FontHeaderParser(StringIO(data))\n  562:             self.cid2unicode = parser.get_encoding()\n  563          return\n  564  \n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\pdfminer\\pdftypes.py:\n   11  \n   12  # Abbreviation of Filter names in PDF 4.8.6. \"Inline Images\"\n   13: LITERALS_FLATE_DECODE = (LIT('FlateDecode'), LIT('Fl'))\n   14: LITERALS_LZW_DECODE = (LIT('LZWDecode'), LIT('LZW'))\n   15: LITERALS_ASCII85_DECODE = (LIT('ASCII85Decode'), LIT('A85'))\n   16: LITERALS_ASCIIHEX_DECODE = (LIT('ASCIIHexDecode'), LIT('AHx'))\n   17: LITERALS_RUNLENGTH_DECODE = (LIT('RunLengthDecode'), LIT('RL'))\n   18: LITERALS_CCITTFAX_DECODE = (LIT('CCITTFaxDecode'), LIT('CCF'))\n   19: LITERALS_DCT_DECODE = (LIT('DCTDecode'), LIT('DCT'))\n   20  \n   21  \n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\tools\\conv_cmap.py:\n   81                  vertical = code.endswith('v')\n   82                  if vertical:\n   83:                     code = code[:-1]\n   84                  try:\n   85:                     code = code.decode('hex')\n   86                  except:\n   87:                     code = chr(int(code, 16))\n   88                  if vertical:\n   89                      vcodes.append(code)\n   ..\n  106                      put(vmap, code, cid)\n  107                  if name.endswith('-UTF8') and hcodes:\n  108:                     code = get_unichr(hcodes)\n  109                      if cid not in cid2unichr_h:\n  110                          cid2unichr_h[cid] = code\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\tools\\conv_glyphlist.py:\n   16          if state == 0:\n   17              print\n   18:             print 'glyphname2unicode = {'\n   19              state = 1\n   20          (name,x) = line.split(';')\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\model\\show.py:\n   12      \n   13      def __init__(self, code, club, locations, dates):\n   14:         self.code = code;\n   15          self.clubs = set();\n   16          self.addClub(club);\n   ..\n  139      \n  140      def __eq__(self, other):\n  141:         return self.code == other.code;\n  142  \n  143      def __hash__(self):\n\n66 matches across 22 files\n\n\nSearching 75 files for \"searching\"\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\demo.py:\n  113      def _parseShowPage(self):\n  114          if VERBOSE:\n  115:             print(\"Searching \" + self._pagelink)\n  116          if OFFLINE:\n  117              self._pagelink = 'file:///C|/Users/Taylor/workspace/Python/scrapping/local/showpage.htm'\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\showscraper.py:\n   35          #open page\n   36          if self.VERBOSE:\n   37:             print(\"Searching \" + showPageUrl)\n   38          if self.OFFLINE:\n   39              showPageUrl = config.Onofrio.LOCAL_PAGE \n\n2 matches across 2 files\n\n\nSearching 75 files for \"datepairs\"\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\showscraper.py:\n  114          locationTimes=descLine.findAll('dd')\n  115          print( \"locationTimes: \" + str(locationTimes))\n  116:         locationDatePairs = list();\n  117          for locationTime in locationTimes:\n  118              raw = locationTime.findAll(text=True)[0];\n  ...\n  120                  print(\"Raw date/location: \" + str(raw));\n  121              locationDatePair = RegexHelper().getLocationDate(raw); \n  122:             locationDatePairs.append(locationDatePair);\n  123:             print(\"locationDatePairs: \" + str(locationDatePairs))\n  124          companionShows = list()\n  125          for i in range(0,len(clubNames)):\n  126              print(\"i: \" + str(i))\n  127              print(\"club: \" + str(clubNames[i]));\n  128:             print(\"pair one: \" + str(locationDatePairs[i][1]));\n  129:             print(\"pair zero: \" + str(locationDatePairs[i][0]));\n  130:             companionShows.append(CompanionShow(clubNames[i], locationDatePairs[i][1], locationDatePairs[i][0]))\n  131          return companionShows;\n  132  \n\n8 matches in 1 file\n\n\nSearching 75 files for \"adding da\"\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\model\\show.py:\n   53      \n   54      def addDate(self, date):\n   55:         print('adding date ' + str(date));\n   56          self.dates.add(date);\n   57          print('now dates has ' + str(len(self.dates)))\n\n1 match in 1 file\n\n\nSearching 75 files for \"_pullshow\"\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\showscraper.py:\n   26              self.VERBOSE = verbose;\n   27          \n   28:         #self._allshows = self._pullShowsFromOnofrio()\n   29          #self._uniqueshows = self._getUniqueShows();\n   30      \n   ..\n   46              location = self._parseLocation(pool);\n   47              #self._hasProgram = self._checkIfProgram(pool);\n   48:             code = self._pullShowCode(pool);\n   49              if self.VERBOSE:\n   50                  print('code:' + str(code));\n   ..\n  148          #return ScrapeHelper.pullAnchorText(link, RegexHelper.getPattern(RegexPattern.KENNEL_CLUB));\n  149  \n  150:     def _pullShowCode(self, pool):\n  151:         #print(\"_pullShowCode not implemented\")\n  152          #sys.exit(1);\n  153          notAvailable = pool.findAll(text=\"Judging Program Not Available\");\n  ...\n  155              results = pool.findAll('a', href=True, text='Judging Program (PDF Format)');\n  156              if results:\n  157:                 print('_pullShowCode found the program anchor');\n  158                  self.pdfLink = results[0]['href'];\n  159                  code = re.search(\"(?P<name>(?P<code>[A-Z]+[0-9])\\JP.pdf)\", self.pdfLink).group('code')\n  ...\n  167  \n  168      def _pullPdfLink(self, pool):\n  169:         #print(\"_pullShowCode not implemented\")\n  170          #sys.exit(1);\n  171          notAvailable = pool.findAll(text=\"Judging Program Not Available\");\n\n6 matches in 1 file\n\n\nSearching 75 files for \"print(\"\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\appserver_accessor.py:\n    7          print (\"Posting show JSON to server...\");\n    8          url = config.AppServer.SHOW_POST_URL\n    9:         print(url);\n   10          values = {'name':show._club,  'date':int(show.date)*1000, 'city':show.city, 'state':show.state, 'show':showJson}\n   11          #values = {'city': 'Columbiana', 'date': 1365138000.0, 'name': 'Northeast Oklahoma Kennel Club', 'state': 'AL'}\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\demo.py:\n   32      values = {'name':show._club,  'date':int(show.date), 'city':show.city, 'state':show.state}\n   33      #values = {'city': 'Columbiana', 'date': 1365138000.0, 'name': 'Northeast Oklahoma Kennel Club', 'state': 'AL'}\n   34:     print(str(values));\n   35      response = urlopen_with_retry(url, values)\n   36  \n   37      #response = urlopen_with_retry(url, data.encode('utf8'))\n   38      the_page = response.read()\n   39:     print(\"response page: \" + str(the_page))\n   40  \n   41  \n   ..\n   64      @property\n   65      def date(self):\n   66:         print(self._date)\n   67          match = re.search(\"(?P<month>\"+month_regex+\") (?P<day>\\d+)[0-9-]*, (?P<year>\\d{4})\", self._date);\n   68          date = match.group(\"month\") + ' ' +match.group(\"day\") + ' ' + match.group('year')\n   ..\n   79          raw = headings[0].findAll(text=True)[0];\n   80          if VERBOSE:\n   81:             print(\"Raw location: \" + raw);\n   82          match = re.search(\"(?P<city>.*) (?P<state>[A-Z][A-Z])\", raw);\n   83          pretty = match.group('city') + \", \" + match.group('state')\n   ..\n   85          self._state = match.group('state')\n   86          if VERBOSE:\n   87:             print(\"Pretty location: \" + pretty)\n   88          return pretty;\n   89      def _parseStartDate(self, pool): \n   ..\n   91          raw = headings[1].findAll(text=True)[0]\n   92          if VERBOSE:\n   93:             print(\"Raw date: \" + raw);\n   94          pretty = re.search(\"- (?P<date>(\"+month_regex+\") .*)\", raw).group('date');\n   95          if VERBOSE:\n   96:             print(\"Pretty date: \" + pretty)\n   97          return pretty;\n   98      \n   ..\n  106                  return True;\n  107              else:\n  108:                 print(\"died: \" + str(results) + \" \" + self._pagelink)\n  109                  return False;\n  110          else:\n  ...\n  113      def _parseShowPage(self):\n  114          if VERBOSE:\n  115:             print(\"Searching \" + self._pagelink)\n  116          if OFFLINE:\n  117              self._pagelink = 'file:///C|/Users/Taylor/workspace/Python/scrapping/local/showpage.htm'\n  ...\n  126          if not OFFLINE and DO_DOWNLOAD and self._hasProgram:\n  127              if not self._pdfLink:\n  128:                 print(\"download died: \" + self._pagelink)\n  129                  return False;\n  130              #self._programcode = \"PPTO1\";\n  ...\n  133              path = os.getcwd() + \"/programs/\"+pdfName;\n  134              \n  135:             print(\"*** Downloading ***\" + url);\n  136              (filename, headers) = urllib.request.urlretrieve(url, path)\n  137              f = open(filename)\n  138              f.close();\n  139              if VERBOSE:\n  140:                 print(filename)\n  141              return True;\n  142          else:\n  ...\n  187              show = Show(club, baseUrl+link, code)\n  188              shows.append(show)\n  189:             #print(show);\n  190      yes = 0\n  191      no = 0;\n  ...\n  203              if show._hasProgram:\n  204                  if show.programName is None:\n  205:                     print(\"program but no name in \" + show._pagelink)\n  206                  else:\n  207:                     print(\"duplicate: \" + show.programName)\n  208  \n  209      total = yes + no\n  210:     print(str(yes) + \" of \" + str(total) + \" shows have programs\")\n  211      return shows;\n  212  def main():\n  213:     print(\"Pulling...\")\n  214      shows = pullShowsFromOnofrio()\n  215      prevClub = None\n  ...\n  217          if show._club != prevClub:\n  218              postShow(show);\n  219:             print(\"new club \" + show._club + \" is not \" + str(prevClub));\n  220              prevClub = show._club\n  221          else:\n  222:             print(\"duplicate club: \"  + prevClub)\n  223  main()\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\dogshowprogramworker.py:\n   32          urlList = self.getClosedShowUrls();\n   33          if showLimit:\n   34:             print('limit of ' + str(showLimit) + ' shows')\n   35              #urlList = urlList[:showLimit];\n   36          showDetailList = list();\n   ..\n   38              showDetail = self.getShowDetails(url);\n   39              if showDetail.code is None:\n   40:                 print(\"No program currently available for \" + str(url));\n   41              else:\n   42                  showDetailList.append(showDetail);\n   43:                 print(\"url: \" + url)\n   44          oldShowCount = len(showDetailList)\n   45          showDetailList = set(showDetailList);\n   46          duplicateShowCount =  oldShowCount - len(showDetailList);\n   47:         print(\"found \" + str(duplicateShowCount) + \" duplicate show entries\")\n   48          if len(showDetailList) > showLimit:\n   49              showDetailList = showDetailList[:showLimit];\n   ..\n   57      \"\"\"\n   58      def getClosedShowUrls(self):\n   59:         print('********************')\n   60:         print('Get Closed Show Urls')\n   61:         print('********************')\n   62          links = self.scraper.pullClosedShows();\n   63:         print('pulled ' + str(len(links)) + 'links');\n   64          return links;\n   65  \n   ..\n   78          if pdfPath:\n   79              showJson = self.getShowJson(pdfPath);\n   80:             print(str(\"collected show JSON: \") + str(showJson is not None))\n   81              if 'Rings' not in showJson:\n   82:                 print(\"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\")\n   83:                 print(\"!!           ERROR                !!\")\n   84:                 print(\"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\")\n   85:                 print(\"Couldn't get JSON from \" + pdfPath )\n   86:                 print(\"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\")\n   87                  return None;\n   88              \n   89              ringDates = self.getRingDates(pdfPath);\n   90:             print(str(\"collected ring dates: \") + str(ringDates is not None))\n   91              if showJson and ringDates:\n   92                  return self.assignDates(showJson, ringDates);\n   ..\n   97      \"\"\"\n   98      def assignDates(self, showJson, ringDates):\n   99:         print(\"*******************\")\n  100:         print(\"* Assigning dates *\");\n  101:         print(\"*******************\")\n  102          ringsList = showJson['Rings'];\n  103          numRings = len(ringsList)\n  104          dates = list(ringDates.keys());\n  105:         print(str(dates))\n  106          currentDateIndex = 0;\n  107          currentDate = dates[currentDateIndex];\n  108          currentDateNumRings = len(ringDates[currentDate])\n  109          assignedRingsCurrentDate = 0;\n  110:         print(\"date list:           \" + str(dates));\n  111:         print(\"numRings in JSON:    \" + str(numRings))\n  112:         print(\"currentDate:         \" + str(currentDate))\n  113:         print(\"currentDateNumRings: \" + str(currentDateNumRings))\n  114  \n  115          # TODO \n  ...\n  117          # Condense ringDates[i] into a set so [1,2,3,4,4,4,5] -> [1,2,3,4,5]\n  118          dates = [set(dates[d]) for d in dates]\n  119:         print(\"Condensed dats: \" + str(dates))\n  120          # Then track the rings so that after each ring number has appeared, jump to the next day \n  121          \n  122:         print('not implemented!')\n  123         \n  124          sys.exit(0)\n  ...\n  127              #TODO is it 'GROUP' or 'Group'?\n  128              if not (assignedRingsCurrentDate < currentDateNumRings or 'GROUP' in ringsList[ringIndex]):\n  129:                 print(str(currentDate) + 'has ' + str(currentDateNumRings) + ' rings.');\n  130                  currentDateIndex=currentDateIndex+1;\n  131                  currentDate = dates[currentDateIndex];\n  ...\n  137          showJson = dict()\n  138          showJson['Rings'] = ringsList;\n  139:         print(\"JSON\")\n  140:         print(\"----\")\n  141:         print(str(showJson))\n  142          # start with first date.\n  143          # assign first n rings that date.\n  ...\n  161          locationList = list();\n  162          [locationList.append(l.toJson()) for l in show.locations];\n  163:         print(json.loads(json.dumps(locationList)))\n  164:         print(show.getDateList())\n  165:         print(str(values));\n  166          values = {'code':show.code, 'locations':json.loads(json.dumps(locationList)), 'clubs':show.getClubList(), 'show':values, 'dates':show.getDateList()}\n  167          #values = {'city': 'Columbiana', 'date': 1365138000.0, 'name': 'Northeast Oklahoma Kennel Club', 'state': 'AL'}\n  ...\n  170          #response = urlopen_with_retry(url, data.encode('utf8'))\n  171          the_page = response.read()\n  172:         print(the_page);\n  173  \n  174      def downloadPrograms(self, shows):\n  175          for show in shows:\n  176:             print(\"Show code: \" + show.code)\n  177              show.downloadProgram()\n  178          return shows\n  ...\n  183      \"\"\"\n  184      def downloadProgram(self, show):\n  185:         print(\"setting pdf path...\")\n  186          pdfPath = config.Pdf.DOWNLOAD_DIR+show.code+\".pdf\";\n  187:         print(\"pdf path is \" + pdfPath)\n  188          if not config.Env.OFFLINE and config.Env.DO_DOWNLOAD:\n  189              if  os.path.isfile(pdfPath):\n  190:                 print(\"Skipping... file already downloaded\");\n  191                  return pdfPath;\n  192              pdfName = show.code;         \n  193:             print(\"*** Downloading ***\" + config.Onofrio.pdfUrl(show.pdfLink));\n  194              (filename, headers) = urllib.request.urlretrieve(config.Onofrio.pdfUrl(show.pdfLink),pdfPath)\n  195              f = open(filename)\n  196              f.close();\n  197              pdfPath = filename\n  198:             print(\"pdf path: \" + pdfPath)\n  199              if config.Env.VERBOSE:\n  200:                 print(filename)\n  201              return pdfPath;\n  202          else:\n  203:             print(\"Did not download program!\")\n  204:             print(\"Does it exist? \" + str(os.path.isfile(pdfPath)))\n  205              if os.path.isfile(pdfPath):\n  206:                 print(\"program exists at: \" + pdfPath)\n  207                  return pdfPath;\n  208              return False; \n  209  \n  210      def scrapeAndDownload(self):\n  211:         print(\"scrape and download\");\n  212          scraper = ShowScraper(False, False);\n  213:         print(\"pulling shows...\");\n  214          allshows = scraper.getAllShows()\n  215:         print(\"posting shows...\");\n  216  \n  217          shows = scraper.getUniqueShows()\n  218:         print(\"downloading \" + str(len(shows)) + \" programs...\")\n  219          downloadPrograms(shows)\n  220          \n  ...\n  228                  uniqueShows[-1:].dateList.append(show.date);\n  229          for show in uniqueShowList:\n  230:             print( str(show.programName) + \" lasts \" + str(len(show.dateList)) + \" days\" );\n  231          return (allshows, shows);\n  232  \n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\driver.py:\n   18      locationList = list();\n   19      [locationList.append(l.toJson()) for l in show.locations];\n   20:     print(json.loads(json.dumps(locationList)))\n   21:     print(show.getDateList())\n   22:     print(str(values));\n   23      values = {'code':show.code, 'locations':json.loads(json.dumps(locationList)), 'clubs':show.getClubList(), 'show':values, 'dates':show.getDateList()}\n   24      #values = {'city': 'Columbiana', 'date': 1365138000.0, 'name': 'Northeast Oklahoma Kennel Club', 'state': 'AL'}\n   ..\n   27      #response = urlopen_with_retry(url, data.encode('utf8'))\n   28      the_page = response.read()\n   29:     print(the_page);\n   30  \n   31  def postShows(shows):\n   ..\n   35  def downloadPrograms(shows):\n   36      for show in shows:\n   37:         print(\"Show code: \" + show.code)\n   38          show.downloadProgram()\n   39      return shows\n   40  \n   41  def scrapeAndDownload():\n   42:     print(\"scrape and download\");\n   43      scraper = ShowScraper(False, False);\n   44:     print(\"pulling shows...\");\n   45      allshows = scraper.getAllShows()\n   46:     print(\"posting shows...\");\n   47  \n   48      shows = scraper.getUniqueShows()\n   49:     print(\"downloading \" + str(len(shows)) + \" programs...\")\n   50      downloadPrograms(shows)\n   51      \n   ..\n   59              uniqueShows[-1:].dateList.append(show.date);\n   60      for show in uniqueShowList:\n   61:         print( str(show.programName) + \" lasts \" + str(len(show.dateList)) + \" days\" );\n   62      return (allshows, shows);\n   63  \n   ..\n   67  def doRunGrammar(show):\n   68  \n   69:     print(\"Running grammar\")\n   70      path = \"./cleaned/KTDC1JP.txt\"\n   71      json = grammar.getShowJson(path);\n   ..\n   90        opts, args = getopt.getopt(argv,\"fp:r:od\",['limit=','download=','offline='])\n   91      except getopt.GetoptError:\n   92:       print('option error. No options?');\n   93        sys.exit(2)\n   94      showLimit = None;\n   ..\n   96      for opt, arg in opts:\n   97        if opt == '--limit':\n   98:         print('limit option of ' + arg)\n   99          showLimit = int(arg);\n  100        if opt == '--nodownload':\n  ...\n  102        if opt == '--download':\n  103          config.Env.DO_DOWNLOAD = arg=='true';\n  104:         print('download: ' + str(config.Env.DO_DOWNLOAD))\n  105        if opt == '--offline':\n  106          config.Env.OFFLINE = arg=='true';\n  107:         print('offline: ' + str(config.Env.OFFLINE))\n  108  \n  109      for opt, arg in opts:\n  110:       print(\"opt: \" + opt)\n  111        if opt == '-r':\n  112           if arg == 'showpage':\n  113:             print('show page')\n  114              show = ShowScraper(False, True).pullShow(requestedPage);\n  115              if show:\n  116:                 print(show.pdfLink)\n  117              sys.exit()\n  118           if arg == 'closed':\n  119:             print(\"closed\");\n  120              links = ShowScraper(False, True).pullClosedShows();\n  121           sys.exit()\n  ...\n  123           requestedPage=arg\n  124        elif opt == '-o':\n  125:         print('offline')\n  126        elif opt == '-d':\n  127           worker = DogshowProgramWorker();\n  ...\n  129           sys.exit(0);\n  130           if arg == 'showpage':\n  131:             print('show page')\n  132              show = ShowScraper(True, True).pullShow(\"blah\");\n  133              if show:\n  134:                 print(show.pdfLink)\n  135                  #downloadProgram(show);\n  136                  postShow(show);\n  137              sys.exit()\n  138           if arg == 'closed':\n  139:             print(\"closed\");\n  140              links = ShowScraper(False, True).pullClosedShows();\n  141:             [print(str(link)) for link in links]\n  142        elif opt == '-f':\n  143          (allshows, uniqueShows) = scrapeAndDownload();\n  ...\n  145          for show in allshows:\n  146              doParseAndClean(show);\n  147:             print(\"programName: \" + show.programName)\n  148              if show.showCode == \"KTDC1\":\n  149:                 print(\"found KTDC1\")\n  150                  json = doRunGrammar(show);\n  151                  AppServerAccessor().postShow(show, json)\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\grammar.py:\n    9      jsonStr = None;\n   10      if not os.path.isfile(outputLocation) or config.Grammar.FORCE:\n   11:         print(\"****************************\")\n   12:         print(\"*      Running grammar     *\")\n   13:         print(\"****************************\")\n   14          proc = subprocess.call(['java', '-jar', config.Grammar.GRAMMAR_JAR, showTxtPath], stdout=open(outputLocation, \"w\"))\n   15      else:\n   16:     	print(\"Show json already obtained from grammar. Reading JSON from file \" + outputLocation)\n   17      with open (outputLocation, \"r\") as jsonFile:\n   18      	return json.load(jsonFile)\n   19      	jsonStr = jsonFile.read();\n   20:     	print(\"read(): \" + str(jsonStr))\n   21      	jsonFile.close();\n   22      	return json.load(jsonFile);\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\parserunner.py:\n   14              output = filename[:-3] + \"txt\"\n   15              outputLocation = config.Parse.OUTPUT_DIR + output\n   16:             print(\"filename: \" + filename + \" parsed to \" + outputLocation );\n   17              subprocess.call(['java', '-jar', 'pdfbox-app-1.7.1.jar', 'ExtractText', pdf, outputLocation])\n   18  \n   ..\n   22      \"\"\"\n   23      def parseProgramPdfBox(self, fullPdfPath):\n   24:         print(\"pdfbox on path: \" +str(fullPdfPath))\n   25          if fullPdfPath is not None:\n   26              output = os.path.basename(fullPdfPath)[:-3] + \"pdfbox.txt\"\n   ..\n   28              #show.parsedPath = outputLocation;\n   29              if os.path.isfile(outputLocation):\n   30:                 print(\"Already exists: \" + outputLocation)\n   31              else:\n   32                  subprocess.call(['java', '-jar', 'pdfbox-app-1.7.1.jar', 'ExtractText', fullPdfPath, outputLocation])\n   ..\n   45                  proc = subprocess.Popen(['python27', './libs/pdfminer-20110515/tools/pdf2txt.py', fullPdfPath],  stdout=open(outputLocation, \"w\"))\n   46              else:\n   47:                 print(\"Already exists: \" + outputLocation + \"; reading from file.\");\n   48              #with codecs.open (outputLocation, \"r\", 'UTF-8') as outputFile:\n   49              #    text = outputFile.read();\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\retry_decorator.py:\n   35                          logger.warning(msg)\n   36                      else:\n   37:                         print(msg)\n   38                      time.sleep(mdelay)\n   39                      mtries -= 1\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\ringcleaner.py:\n   27  				sub = subprocess.call(['sed', '-i','-e', sedCommand, cleanedPath])\n   28  		return cleanedPath\n   29: 		#print(string['Rings']);\n   30  	\n   31  	def cleanPdf2Txt(self, pdfPath):\n   ..\n   34  			shutil.copyfile(pdfPath, cleanedPath)\n   35  			#TODO build into one big command\n   36: 			print(\"running sed on \" + cleanedPath)\n   37  			for sedCommand in RingCleaner.pdf2TxtSedCommands:\n   38  				sub = subprocess.call(['sed', '-i','-e', sedCommand, cleanedPath])\n   ..\n   59  			return grammar.getShowJson(cleanedPath);\n   60  		else:\n   61: 			print('!!! failed to parse ' + str(parsedFilePath) + '!!!');\n   62  \n   63  \n   ..\n   76  		lineArr = str(text).split('\\n');\n   77  \n   78: 		print(str(len(lineArr)) + \" lines after split\");\n   79: 		print(text);\n   80  		dateRingList = [line for line in lineArr if re.match(RegexPatternDef.DATE, line) or re.match(\"RING \\d+\", line)]\n   81: 		print(len(dateRingList));\n   82: 		[print(str(x)) for x in dateRingList]\n   83  		ringCount = 0;\n   84  		datemap = OrderedDict();\n   ..\n   89  			if dateMatch:\n   90  				nextDate = dateMatch.group(1);\n   91: 				print(nextDate);\n   92  				if nextDate != currentDate :\n   93  					if rings:\n   ..\n  103  				if ringMatch:\n  104  					ring = int(ringMatch.group(1))\n  105: 					print(\"Found RING \" + str(ring));\n  106  					rings.append(ring);\n  107  					ringCount = ringCount+1;\n  108  				else:\n  109: 					print(\"Nothing found in line: \" + line);\n  110: 		print(\"found \" + str(ringCount) + \" rings\");\n  111: 		print(str(datemap))\n  112  		return datemap\n  113  \n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\scrapehelper.py:\n   13  \n   14  	def pullAnchorLink(self, anchor, pattern):\n   15: 		print(\"pullAnchorLink is not implemented\")\n   16  		sys.exit(1);\n   17          text = self._getAnchorText(anchor);\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\show.py:\n   81  \n   82      def downloadProgram(self):\n   83:         print(\"setting pdf path...\")\n   84          self._pdfPath = config.Pdf.DOWNLOAD_DIR+self.programName\n   85:         print(\"pdf path is \" + self._pdfPath)\n   86          if not config.Env.OFFLINE and config.Env.DO_DOWNLOAD and self._hasProgram:\n   87              if not self._pdfLink:\n   88:                 print(\"download died: \" + self._pagelink)\n   89                  return False;\n   90              #self._programcode = \"PPTO1\";\n   91              pdfName = self.programName; \n   92              url = config.Onofrio.pdfUrl(self._pdfLink)            \n   93:             print(\"*** Downloading ***\" + url);\n   94              (filename, headers) = urllib.request.urlretrieve(url, path)\n   95              f = open(filename)\n   96              f.close();\n   97              self._pdfPath = filename\n   98:             print(\"pdf path: \" + self._pdfPath)\n   99              if config.Env.VERBOSE:\n  100:                 print(filename)\n  101              return True;\n  102          else:\n  103:             print(\"Did not download program!\")\n  104              return False; \n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\showscraper.py:\n   42              club = self._pullKennelClub(pool);\n   43              if self.VERBOSE:\n   44:                 print(club);\n   45              date = self._parseStartDate(pool);\n   46              location = self._parseLocation(pool);\n   ..\n   48              code = self._pullShowCode(pool);\n   49              if self.VERBOSE:\n   50:                 print('code:' + str(code));\n   51              pdfLink = self._pullPdfLink(pool);\n   52              if self.VERBOSE:\n   53:                 print('pdf link: ' + str(pdfLink));\n   54              show = Show(code, club, location, date);\n   55              show.pdfLink = pdfLink;\n   56              if config.Env.VERBOSE:\n   57:                 print(\"************************************\")\n   58:                 print(\"*   finding companions to \" + str(club) + \"  *\")\n   59:                 print(\"************************************\")\n   60              companionShows = self._parseCompanionShows(pool);\n   61              for c in companionShows:\n   ..\n  101   #               return True;\n  102   #           else:\n  103:  #               print(\"died: \" + str(results) + \" \" + self._pagelink)\n  104   #               return False;\n  105   #       else:\n  ...\n  120              locationDatePair = RegexHelper().getLocationDate(raw); \n  121              locationDatePairs.append(locationDatePair);\n  122:             print(\"locationDatePairs: \" + str(locationDatePairs))\n  123          companionShows = list()\n  124          for i in range(0,len(clubNames)):\n  ...\n  149  \n  150      def _pullShowCode(self, pool):\n  151:         #print(\"_pullShowCode not implemented\")\n  152          #sys.exit(1);\n  153          notAvailable = pool.findAll(text=\"Judging Program Not Available\");\n  ...\n  160                  return code;\n  161              else:\n  162:                 print(\"died: \" + str(results) + \" \" + self._pagelink)\n  163                  return None;\n  164          else:\n  165:             print('show code not available')\n  166              None;\n  167  \n  168      def _pullPdfLink(self, pool):\n  169:         #print(\"_pullShowCode not implemented\")\n  170          #sys.exit(1);\n  171          notAvailable = pool.findAll(text=\"Judging Program Not Available\");\n  ...\n  202                  if show._hasProgram:\n  203                      if show.programName is None and self.VERBOSE :\n  204:                         print(\"program but no name in \" + show._pagelink)\n  205                      elif self.VERBOSE:\n  206:                         print(\"duplicate: \" + show.programName)\n  207  \n  208          return uniqueShows;\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\showutils.py:\n    9      data = None\n   10      if values is not None:\n   11:         print(\"POST REQUEST to \" + url)\n   12          data = urllib.parse.urlencode(values)\n   13          data = data.encode('utf-8') # data should be bytes\n   14      else:\n   15          time.sleep(2);\n   16:         print(\"GET REQUEST to \" + url)\n   17      req = urllib.request.Request(url, data)\n   18      return urllib.request.urlopen(req)\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\util.py:\n    6  def printv(string):\n    7  	if config.Env.VERBOSE:\n    8: 		print(str(string));\n    9  \n   10  class RegexPattern(object):\n   ..\n   55  \n   56  	def pullAnchorLink(self, anchor, pattern):\n   57: 		print(\"pullAnchorLink is not implemented\")\n   58  		sys.exit(1);\n   59  		text = self._getAnchorText(anchor);\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\model\\show.py:\n   17          self.addClub(club);\n   18          self.locations = set();\n   19:         print('initializing dates with ' + str(dates))\n   20          self.dates = set();\n   21          self.dates.add(dates)\n   ..\n  103          raw = headings[0].findAll(text=True)[0];\n  104          if config.Env.VERBOSE:\n  105:             print(\"Raw location: \" + raw);\n  106          match = re.search(\"(?P<city>.*) (?P<state>[A-Z][A-Z])\", raw);\n  107          pretty = match.group('city') + \", \" + match.group('state')\n  ...\n  109          self._state = match.group('state')\n  110          if config.Env.VERBOSE:\n  111:             print(\"Pretty location: \" + pretty)\n  112          return pretty;\n  113  \n  ...\n  117          raw = headings[1].findAll(text=True)[0]\n  118          if config.Env.VERBOSE:\n  119:             print(\"Raw date: \" + raw);\n  120          pretty = re.search(\"- (?P<date>(\"+config.MONTH_REGEX+\") .*)\", raw).group('date');\n  121          if config.Env.VERBOSE:\n  122:             print(\"Pretty date: \" + pretty)\n  123          return pretty;\n  124      \n  ...\n  130              if results:\n  131                  self.pdfLink = results[0]['href'];\n  132:                 print(\"link is \" + self.pdfLink);\n  133                  self.programName = re.search(\"(?P<name>[A-Z]+[0-9]\\JP.pdf)\", self.pdfLink).group('name')\n  134                  return True;\n  135              else:\n  136:                 print(\"died: \" + str(results) + \" \" + self._pagelink)\n  137                  return False;\n  138          else:\n\n149 matches across 14 files\n\n\nSearching 75 files for \"print(\"\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\appserver_accessor.py:\n    7          print (\"Posting show JSON to server...\");\n    8          url = config.AppServer.SHOW_POST_URL\n    9:         print(url);\n   10          values = {'name':show._club,  'date':int(show.date)*1000, 'city':show.city, 'state':show.state, 'show':showJson}\n   11          #values = {'city': 'Columbiana', 'date': 1365138000.0, 'name': 'Northeast Oklahoma Kennel Club', 'state': 'AL'}\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\demo.py:\n   32      values = {'name':show._club,  'date':int(show.date), 'city':show.city, 'state':show.state}\n   33      #values = {'city': 'Columbiana', 'date': 1365138000.0, 'name': 'Northeast Oklahoma Kennel Club', 'state': 'AL'}\n   34:     print(str(values));\n   35      response = urlopen_with_retry(url, values)\n   36  \n   37      #response = urlopen_with_retry(url, data.encode('utf8'))\n   38      the_page = response.read()\n   39:     print(\"response page: \" + str(the_page))\n   40  \n   41  \n   ..\n   64      @property\n   65      def date(self):\n   66:         print(self._date)\n   67          match = re.search(\"(?P<month>\"+month_regex+\") (?P<day>\\d+)[0-9-]*, (?P<year>\\d{4})\", self._date);\n   68          date = match.group(\"month\") + ' ' +match.group(\"day\") + ' ' + match.group('year')\n   ..\n   79          raw = headings[0].findAll(text=True)[0];\n   80          if VERBOSE:\n   81:             print(\"Raw location: \" + raw);\n   82          match = re.search(\"(?P<city>.*) (?P<state>[A-Z][A-Z])\", raw);\n   83          pretty = match.group('city') + \", \" + match.group('state')\n   ..\n   85          self._state = match.group('state')\n   86          if VERBOSE:\n   87:             print(\"Pretty location: \" + pretty)\n   88          return pretty;\n   89      def _parseStartDate(self, pool): \n   ..\n   91          raw = headings[1].findAll(text=True)[0]\n   92          if VERBOSE:\n   93:             print(\"Raw date: \" + raw);\n   94          pretty = re.search(\"- (?P<date>(\"+month_regex+\") .*)\", raw).group('date');\n   95          if VERBOSE:\n   96:             print(\"Pretty date: \" + pretty)\n   97          return pretty;\n   98      \n   ..\n  106                  return True;\n  107              else:\n  108:                 print(\"died: \" + str(results) + \" \" + self._pagelink)\n  109                  return False;\n  110          else:\n  ...\n  113      def _parseShowPage(self):\n  114          if VERBOSE:\n  115:             print(\"Searching \" + self._pagelink)\n  116          if OFFLINE:\n  117              self._pagelink = 'file:///C|/Users/Taylor/workspace/Python/scrapping/local/showpage.htm'\n  ...\n  126          if not OFFLINE and DO_DOWNLOAD and self._hasProgram:\n  127              if not self._pdfLink:\n  128:                 print(\"download died: \" + self._pagelink)\n  129                  return False;\n  130              #self._programcode = \"PPTO1\";\n  ...\n  133              path = os.getcwd() + \"/programs/\"+pdfName;\n  134              \n  135:             print(\"*** Downloading ***\" + url);\n  136              (filename, headers) = urllib.request.urlretrieve(url, path)\n  137              f = open(filename)\n  138              f.close();\n  139              if VERBOSE:\n  140:                 print(filename)\n  141              return True;\n  142          else:\n  ...\n  187              show = Show(club, baseUrl+link, code)\n  188              shows.append(show)\n  189:             #print(show);\n  190      yes = 0\n  191      no = 0;\n  ...\n  203              if show._hasProgram:\n  204                  if show.programName is None:\n  205:                     print(\"program but no name in \" + show._pagelink)\n  206                  else:\n  207:                     print(\"duplicate: \" + show.programName)\n  208  \n  209      total = yes + no\n  210:     print(str(yes) + \" of \" + str(total) + \" shows have programs\")\n  211      return shows;\n  212  def main():\n  213:     print(\"Pulling...\")\n  214      shows = pullShowsFromOnofrio()\n  215      prevClub = None\n  ...\n  217          if show._club != prevClub:\n  218              postShow(show);\n  219:             print(\"new club \" + show._club + \" is not \" + str(prevClub));\n  220              prevClub = show._club\n  221          else:\n  222:             print(\"duplicate club: \"  + prevClub)\n  223  main()\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\dogshowprogramworker.py:\n   32          urlList = self.getClosedShowUrls();\n   33          if showLimit:\n   34:             print('limit of ' + str(showLimit) + ' shows')\n   35              #urlList = urlList[:showLimit];\n   36          showDetailList = list();\n   ..\n   38              showDetail = self.getShowDetails(url);\n   39              if showDetail.code is None:\n   40:                 print(\"No program currently available for \" + str(url));\n   41              else:\n   42                  showDetailList.append(showDetail);\n   43:                 print(\"url: \" + url)\n   44          oldShowCount = len(showDetailList)\n   45          showDetailList = set(showDetailList);\n   46          duplicateShowCount =  oldShowCount - len(showDetailList);\n   47:         print(\"found \" + str(duplicateShowCount) + \" duplicate show entries\")\n   48          if len(showDetailList) > showLimit:\n   49              showDetailList = showDetailList[:showLimit];\n   ..\n   57      \"\"\"\n   58      def getClosedShowUrls(self):\n   59:         print('********************')\n   60:         print('Get Closed Show Urls')\n   61:         print('********************')\n   62          links = self.scraper.pullClosedShows();\n   63:         print('pulled ' + str(len(links)) + 'links');\n   64          return links;\n   65  \n   ..\n   78          if pdfPath:\n   79              showJson = self.getShowJson(pdfPath);\n   80:             print(str(\"collected show JSON: \") + str(showJson is not None))\n   81              if 'Rings' not in showJson:\n   82:                 print(\"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\")\n   83:                 print(\"!!           ERROR                !!\")\n   84:                 print(\"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\")\n   85:                 print(\"Couldn't get JSON from \" + pdfPath )\n   86:                 print(\"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\")\n   87                  return None;\n   88              \n   89              ringDates = self.getRingDates(pdfPath);\n   90:             print(str(\"collected ring dates: \") + str(ringDates is not None))\n   91              if showJson and ringDates:\n   92                  return self.assignDates(showJson, ringDates);\n   ..\n   97      \"\"\"\n   98      def assignDates(self, showJson, ringDates):\n   99:         print(\"*******************\")\n  100:         print(\"* Assigning dates *\");\n  101:         print(\"*******************\")\n  102          ringsList = showJson['Rings'];\n  103          numRings = len(ringsList)\n  104          dates = list(ringDates.keys());\n  105:         print(str(dates))\n  106          currentDateIndex = 0;\n  107          currentDate = dates[currentDateIndex];\n  108          currentDateNumRings = len(ringDates[currentDate])\n  109          assignedRingsCurrentDate = 0;\n  110:         print(\"date list:           \" + str(dates));\n  111:         print(\"numRings in JSON:    \" + str(numRings))\n  112:         print(\"currentDate:         \" + str(currentDate))\n  113:         print(\"currentDateNumRings: \" + str(currentDateNumRings))\n  114  \n  115          # TODO \n  ...\n  117          # Condense ringDates[i] into a set so [1,2,3,4,4,4,5] -> [1,2,3,4,5]\n  118          dates = [set(dates[d]) for d in dates]\n  119:         print(\"Condensed dats: \" + str(dates))\n  120          # Then track the rings so that after each ring number has appeared, jump to the next day \n  121          \n  122:         print('not implemented!')\n  123         \n  124          sys.exit(0)\n  ...\n  127              #TODO is it 'GROUP' or 'Group'?\n  128              if not (assignedRingsCurrentDate < currentDateNumRings or 'GROUP' in ringsList[ringIndex]):\n  129:                 print(str(currentDate) + 'has ' + str(currentDateNumRings) + ' rings.');\n  130                  currentDateIndex=currentDateIndex+1;\n  131                  currentDate = dates[currentDateIndex];\n  ...\n  137          showJson = dict()\n  138          showJson['Rings'] = ringsList;\n  139:         print(\"JSON\")\n  140:         print(\"----\")\n  141:         print(str(showJson))\n  142          # start with first date.\n  143          # assign first n rings that date.\n  ...\n  161          locationList = list();\n  162          [locationList.append(l.toJson()) for l in show.locations];\n  163:         print(json.loads(json.dumps(locationList)))\n  164:         print(show.getDateList())\n  165:         print(str(values));\n  166          values = {'code':show.code, 'locations':json.loads(json.dumps(locationList)), 'clubs':show.getClubList(), 'show':values, 'dates':show.getDateList()}\n  167          #values = {'city': 'Columbiana', 'date': 1365138000.0, 'name': 'Northeast Oklahoma Kennel Club', 'state': 'AL'}\n  ...\n  170          #response = urlopen_with_retry(url, data.encode('utf8'))\n  171          the_page = response.read()\n  172:         print(the_page);\n  173  \n  174      def downloadPrograms(self, shows):\n  175          for show in shows:\n  176:             print(\"Show code: \" + show.code)\n  177              show.downloadProgram()\n  178          return shows\n  ...\n  183      \"\"\"\n  184      def downloadProgram(self, show):\n  185:         print(\"setting pdf path...\")\n  186          pdfPath = config.Pdf.DOWNLOAD_DIR+show.code+\".pdf\";\n  187:         print(\"pdf path is \" + pdfPath)\n  188          if not config.Env.OFFLINE and config.Env.DO_DOWNLOAD:\n  189              if  os.path.isfile(pdfPath):\n  190:                 print(\"Skipping... file already downloaded\");\n  191                  return pdfPath;\n  192              pdfName = show.code;         \n  193:             print(\"*** Downloading ***\" + config.Onofrio.pdfUrl(show.pdfLink));\n  194              (filename, headers) = urllib.request.urlretrieve(config.Onofrio.pdfUrl(show.pdfLink),pdfPath)\n  195              f = open(filename)\n  196              f.close();\n  197              pdfPath = filename\n  198:             print(\"pdf path: \" + pdfPath)\n  199              if config.Env.VERBOSE:\n  200:                 print(filename)\n  201              return pdfPath;\n  202          else:\n  203:             print(\"Did not download program!\")\n  204:             print(\"Does it exist? \" + str(os.path.isfile(pdfPath)))\n  205              if os.path.isfile(pdfPath):\n  206:                 print(\"program exists at: \" + pdfPath)\n  207                  return pdfPath;\n  208              return False; \n  209  \n  210      def scrapeAndDownload(self):\n  211:         print(\"scrape and download\");\n  212          scraper = ShowScraper(False, False);\n  213:         print(\"pulling shows...\");\n  214          allshows = scraper.getAllShows()\n  215:         print(\"posting shows...\");\n  216  \n  217          shows = scraper.getUniqueShows()\n  218:         print(\"downloading \" + str(len(shows)) + \" programs...\")\n  219          downloadPrograms(shows)\n  220          \n  ...\n  228                  uniqueShows[-1:].dateList.append(show.date);\n  229          for show in uniqueShowList:\n  230:             print( str(show.programName) + \" lasts \" + str(len(show.dateList)) + \" days\" );\n  231          return (allshows, shows);\n  232  \n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\driver.py:\n   18      locationList = list();\n   19      [locationList.append(l.toJson()) for l in show.locations];\n   20:     print(json.loads(json.dumps(locationList)))\n   21:     print(show.getDateList())\n   22:     print(str(values));\n   23      values = {'code':show.code, 'locations':json.loads(json.dumps(locationList)), 'clubs':show.getClubList(), 'show':values, 'dates':show.getDateList()}\n   24      #values = {'city': 'Columbiana', 'date': 1365138000.0, 'name': 'Northeast Oklahoma Kennel Club', 'state': 'AL'}\n   ..\n   27      #response = urlopen_with_retry(url, data.encode('utf8'))\n   28      the_page = response.read()\n   29:     print(the_page);\n   30  \n   31  def postShows(shows):\n   ..\n   35  def downloadPrograms(shows):\n   36      for show in shows:\n   37:         print(\"Show code: \" + show.code)\n   38          show.downloadProgram()\n   39      return shows\n   40  \n   41  def scrapeAndDownload():\n   42:     print(\"scrape and download\");\n   43      scraper = ShowScraper(False, False);\n   44:     print(\"pulling shows...\");\n   45      allshows = scraper.getAllShows()\n   46:     print(\"posting shows...\");\n   47  \n   48      shows = scraper.getUniqueShows()\n   49:     print(\"downloading \" + str(len(shows)) + \" programs...\")\n   50      downloadPrograms(shows)\n   51      \n   ..\n   59              uniqueShows[-1:].dateList.append(show.date);\n   60      for show in uniqueShowList:\n   61:         print( str(show.programName) + \" lasts \" + str(len(show.dateList)) + \" days\" );\n   62      return (allshows, shows);\n   63  \n   ..\n   67  def doRunGrammar(show):\n   68  \n   69:     print(\"Running grammar\")\n   70      path = \"./cleaned/KTDC1JP.txt\"\n   71      json = grammar.getShowJson(path);\n   ..\n   90        opts, args = getopt.getopt(argv,\"fp:r:od\",['limit=','download=','offline='])\n   91      except getopt.GetoptError:\n   92:       print('option error. No options?');\n   93        sys.exit(2)\n   94      showLimit = None;\n   ..\n   96      for opt, arg in opts:\n   97        if opt == '--limit':\n   98:         print('limit option of ' + arg)\n   99          showLimit = int(arg);\n  100        if opt == '--nodownload':\n  ...\n  102        if opt == '--download':\n  103          config.Env.DO_DOWNLOAD = arg=='true';\n  104:         print('download: ' + str(config.Env.DO_DOWNLOAD))\n  105        if opt == '--offline':\n  106          config.Env.OFFLINE = arg=='true';\n  107:         print('offline: ' + str(config.Env.OFFLINE))\n  108  \n  109      for opt, arg in opts:\n  110:       print(\"opt: \" + opt)\n  111        if opt == '-r':\n  112           if arg == 'showpage':\n  113:             print('show page')\n  114              show = ShowScraper(False, True).pullShow(requestedPage);\n  115              if show:\n  116:                 print(show.pdfLink)\n  117              sys.exit()\n  118           if arg == 'closed':\n  119:             print(\"closed\");\n  120              links = ShowScraper(False, True).pullClosedShows();\n  121           sys.exit()\n  ...\n  123           requestedPage=arg\n  124        elif opt == '-o':\n  125:         print('offline')\n  126        elif opt == '-d':\n  127           worker = DogshowProgramWorker();\n  ...\n  129           sys.exit(0);\n  130           if arg == 'showpage':\n  131:             print('show page')\n  132              show = ShowScraper(True, True).pullShow(\"blah\");\n  133              if show:\n  134:                 print(show.pdfLink)\n  135                  #downloadProgram(show);\n  136                  postShow(show);\n  137              sys.exit()\n  138           if arg == 'closed':\n  139:             print(\"closed\");\n  140              links = ShowScraper(False, True).pullClosedShows();\n  141:             [print(str(link)) for link in links]\n  142        elif opt == '-f':\n  143          (allshows, uniqueShows) = scrapeAndDownload();\n  ...\n  145          for show in allshows:\n  146              doParseAndClean(show);\n  147:             print(\"programName: \" + show.programName)\n  148              if show.showCode == \"KTDC1\":\n  149:                 print(\"found KTDC1\")\n  150                  json = doRunGrammar(show);\n  151                  AppServerAccessor().postShow(show, json)\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\grammar.py:\n    9      jsonStr = None;\n   10      if not os.path.isfile(outputLocation) or config.Grammar.FORCE:\n   11:         print(\"****************************\")\n   12:         print(\"*      Running grammar     *\")\n   13:         print(\"****************************\")\n   14          proc = subprocess.call(['java', '-jar', config.Grammar.GRAMMAR_JAR, showTxtPath], stdout=open(outputLocation, \"w\"))\n   15      else:\n   16:     	print(\"Show json already obtained from grammar. Reading JSON from file \" + outputLocation)\n   17      with open (outputLocation, \"r\") as jsonFile:\n   18      	return json.load(jsonFile)\n   19      	jsonStr = jsonFile.read();\n   20:     	print(\"read(): \" + str(jsonStr))\n   21      	jsonFile.close();\n   22      	return json.load(jsonFile);\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\parserunner.py:\n   14              output = filename[:-3] + \"txt\"\n   15              outputLocation = config.Parse.OUTPUT_DIR + output\n   16:             print(\"filename: \" + filename + \" parsed to \" + outputLocation );\n   17              subprocess.call(['java', '-jar', 'pdfbox-app-1.7.1.jar', 'ExtractText', pdf, outputLocation])\n   18  \n   ..\n   22      \"\"\"\n   23      def parseProgramPdfBox(self, fullPdfPath):\n   24:         print(\"pdfbox on path: \" +str(fullPdfPath))\n   25          if fullPdfPath is not None:\n   26              output = os.path.basename(fullPdfPath)[:-3] + \"pdfbox.txt\"\n   ..\n   28              #show.parsedPath = outputLocation;\n   29              if os.path.isfile(outputLocation):\n   30:                 print(\"Already exists: \" + outputLocation)\n   31              else:\n   32                  subprocess.call(['java', '-jar', 'pdfbox-app-1.7.1.jar', 'ExtractText', fullPdfPath, outputLocation])\n   ..\n   45                  proc = subprocess.Popen(['python27', './libs/pdfminer-20110515/tools/pdf2txt.py', fullPdfPath],  stdout=open(outputLocation, \"w\"))\n   46              else:\n   47:                 print(\"Already exists: \" + outputLocation + \"; reading from file.\");\n   48              #with codecs.open (outputLocation, \"r\", 'UTF-8') as outputFile:\n   49              #    text = outputFile.read();\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\retry_decorator.py:\n   35                          logger.warning(msg)\n   36                      else:\n   37:                         print(msg)\n   38                      time.sleep(mdelay)\n   39                      mtries -= 1\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\ringcleaner.py:\n   27  				sub = subprocess.call(['sed', '-i','-e', sedCommand, cleanedPath])\n   28  		return cleanedPath\n   29: 		#print(string['Rings']);\n   30  	\n   31  	def cleanPdf2Txt(self, pdfPath):\n   ..\n   34  			shutil.copyfile(pdfPath, cleanedPath)\n   35  			#TODO build into one big command\n   36: 			print(\"running sed on \" + cleanedPath)\n   37  			for sedCommand in RingCleaner.pdf2TxtSedCommands:\n   38  				sub = subprocess.call(['sed', '-i','-e', sedCommand, cleanedPath])\n   ..\n   59  			return grammar.getShowJson(cleanedPath);\n   60  		else:\n   61: 			print('!!! failed to parse ' + str(parsedFilePath) + '!!!');\n   62  \n   63  \n   ..\n   76  		lineArr = str(text).split('\\n');\n   77  \n   78: 		print(str(len(lineArr)) + \" lines after split\");\n   79: 		print(text);\n   80  		dateRingList = [line for line in lineArr if re.match(RegexPatternDef.DATE, line) or re.match(\"RING \\d+\", line)]\n   81: 		print(len(dateRingList));\n   82: 		[print(str(x)) for x in dateRingList]\n   83  		ringCount = 0;\n   84  		datemap = OrderedDict();\n   ..\n   89  			if dateMatch:\n   90  				nextDate = dateMatch.group(1);\n   91: 				print(nextDate);\n   92  				if nextDate != currentDate :\n   93  					if rings:\n   ..\n  103  				if ringMatch:\n  104  					ring = int(ringMatch.group(1))\n  105: 					print(\"Found RING \" + str(ring));\n  106  					rings.append(ring);\n  107  					ringCount = ringCount+1;\n  108  				else:\n  109: 					print(\"Nothing found in line: \" + line);\n  110: 		print(\"found \" + str(ringCount) + \" rings\");\n  111: 		print(str(datemap))\n  112  		return datemap\n  113  \n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\scrapehelper.py:\n   13  \n   14  	def pullAnchorLink(self, anchor, pattern):\n   15: 		print(\"pullAnchorLink is not implemented\")\n   16  		sys.exit(1);\n   17          text = self._getAnchorText(anchor);\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\show.py:\n   81  \n   82      def downloadProgram(self):\n   83:         print(\"setting pdf path...\")\n   84          self._pdfPath = config.Pdf.DOWNLOAD_DIR+self.programName\n   85:         print(\"pdf path is \" + self._pdfPath)\n   86          if not config.Env.OFFLINE and config.Env.DO_DOWNLOAD and self._hasProgram:\n   87              if not self._pdfLink:\n   88:                 print(\"download died: \" + self._pagelink)\n   89                  return False;\n   90              #self._programcode = \"PPTO1\";\n   91              pdfName = self.programName; \n   92              url = config.Onofrio.pdfUrl(self._pdfLink)            \n   93:             print(\"*** Downloading ***\" + url);\n   94              (filename, headers) = urllib.request.urlretrieve(url, path)\n   95              f = open(filename)\n   96              f.close();\n   97              self._pdfPath = filename\n   98:             print(\"pdf path: \" + self._pdfPath)\n   99              if config.Env.VERBOSE:\n  100:                 print(filename)\n  101              return True;\n  102          else:\n  103:             print(\"Did not download program!\")\n  104              return False; \n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\showscraper.py:\n   42              club = self._pullKennelClub(pool);\n   43              if self.VERBOSE:\n   44:                 print(club);\n   45              date = self._parseStartDate(pool);\n   46              location = self._parseLocation(pool);\n   ..\n   48              code = self._pullShowCode(pool);\n   49              if self.VERBOSE:\n   50:                 print('code:' + str(code));\n   51              pdfLink = self._pullPdfLink(pool);\n   52              if self.VERBOSE:\n   53:                 print('pdf link: ' + str(pdfLink));\n   54              show = Show(code, club, location, date);\n   55              show.pdfLink = pdfLink;\n   56              if config.Env.VERBOSE:\n   57:                 print(\"************************************\")\n   58:                 print(\"*   finding companions to \" + str(club) + \"  *\")\n   59:                 print(\"************************************\")\n   60              companionShows = self._parseCompanionShows(pool);\n   61              for c in companionShows:\n   ..\n  101   #               return True;\n  102   #           else:\n  103:  #               print(\"died: \" + str(results) + \" \" + self._pagelink)\n  104   #               return False;\n  105   #       else:\n  ...\n  120              locationDatePair = RegexHelper().getLocationDate(raw); \n  121              locationDatePairs.append(locationDatePair);\n  122:             print(\"locationDatePairs: \" + str(locationDatePairs))\n  123          companionShows = list()\n  124          for i in range(0,len(clubNames)):\n  ...\n  149  \n  150      def _pullShowCode(self, pool):\n  151:         #print(\"_pullShowCode not implemented\")\n  152          #sys.exit(1);\n  153          notAvailable = pool.findAll(text=\"Judging Program Not Available\");\n  ...\n  160                  return code;\n  161              else:\n  162:                 print(\"died: \" + str(results) + \" \" + self._pagelink)\n  163                  return None;\n  164          else:\n  165:             print('show code not available')\n  166              None;\n  167  \n  168      def _pullPdfLink(self, pool):\n  169:         #print(\"_pullShowCode not implemented\")\n  170          #sys.exit(1);\n  171          notAvailable = pool.findAll(text=\"Judging Program Not Available\");\n  ...\n  202                  if show._hasProgram:\n  203                      if show.programName is None and self.VERBOSE :\n  204:                         print(\"program but no name in \" + show._pagelink)\n  205                      elif self.VERBOSE:\n  206:                         print(\"duplicate: \" + show.programName)\n  207  \n  208          return uniqueShows;\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\showutils.py:\n    9      data = None\n   10      if values is not None:\n   11:         print(\"POST REQUEST to \" + url)\n   12          data = urllib.parse.urlencode(values)\n   13          data = data.encode('utf-8') # data should be bytes\n   14      else:\n   15          time.sleep(2);\n   16:         print(\"GET REQUEST to \" + url)\n   17      req = urllib.request.Request(url, data)\n   18      return urllib.request.urlopen(req)\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\util.py:\n    6  def printv(string):\n    7  	if config.Env.VERBOSE:\n    8: 		print(str(string));\n    9  \n   10  class RegexPattern(object):\n   ..\n   55  \n   56  	def pullAnchorLink(self, anchor, pattern):\n   57: 		print(\"pullAnchorLink is not implemented\")\n   58  		sys.exit(1);\n   59  		text = self._getAnchorText(anchor);\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\model\\show.py:\n   17          self.addClub(club);\n   18          self.locations = set();\n   19:         print('initializing dates with ' + str(dates))\n   20          self.dates = set();\n   21          self.dates.add(dates)\n   ..\n  103          raw = headings[0].findAll(text=True)[0];\n  104          if config.Env.VERBOSE:\n  105:             print(\"Raw location: \" + raw);\n  106          match = re.search(\"(?P<city>.*) (?P<state>[A-Z][A-Z])\", raw);\n  107          pretty = match.group('city') + \", \" + match.group('state')\n  ...\n  109          self._state = match.group('state')\n  110          if config.Env.VERBOSE:\n  111:             print(\"Pretty location: \" + pretty)\n  112          return pretty;\n  113  \n  ...\n  117          raw = headings[1].findAll(text=True)[0]\n  118          if config.Env.VERBOSE:\n  119:             print(\"Raw date: \" + raw);\n  120          pretty = re.search(\"- (?P<date>(\"+config.MONTH_REGEX+\") .*)\", raw).group('date');\n  121          if config.Env.VERBOSE:\n  122:             print(\"Pretty date: \" + pretty)\n  123          return pretty;\n  124      \n  ...\n  130              if results:\n  131                  self.pdfLink = results[0]['href'];\n  132:                 print(\"link is \" + self.pdfLink);\n  133                  self.programName = re.search(\"(?P<name>[A-Z]+[0-9]\\JP.pdf)\", self.pdfLink).group('name')\n  134                  return True;\n  135              else:\n  136:                 print(\"died: \" + str(results) + \" \" + self._pagelink)\n  137                  return False;\n  138          else:\n\n149 matches across 14 files\n\n\nSearching 75 files for \".run\"\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\driver.py:\n  126        elif opt == '-d':\n  127           worker = DogshowProgramWorker();\n  128:          worker.run(showLimit);\n  129           sys.exit(0);\n  130           if arg == 'showpage':\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\build\\lib\\pdfminer\\cmapdb.py:\n  414          cmap = FileUnicodeMap()\n  415          #cmap = FileCMap()\n  416:         CMapParser(cmap, fp).run()\n  417          fp.close()\n  418          cmap.dump()\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\build\\lib\\pdfminer\\layout.py:\n   19          elif isinstance(obj, LTTextGroup):\n   20              for x in obj:\n   21:                 self.run(x)\n   22          return\n   23  \n   ..\n  629          for group in groups:\n  630              group.analyze(laparams)\n  631:             assigner.run(group)\n  632          textboxes.sort(key=lambda box:box.index)\n  633          self._objs = textboxes + otherobjs + empties\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\build\\lib\\pdfminer\\lzw.py:\n   95      \"\"\"\n   96      fp = StringIO(data)\n   97:     return ''.join(LZWDecoder(fp).run())\n   98  \n   99  if __name__ == '__main__':\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\build\\lib\\pdfminer\\pdffont.py:\n  520              strm = stream_value(spec['ToUnicode'])\n  521              self.unicode_map = FileUnicodeMap()\n  522:             CMapParser(self.unicode_map, StringIO(strm.get_data())).run()\n  523          PDFFont.__init__(self, descriptor, widths)\n  524          return\n  ...\n  635              strm = stream_value(spec['ToUnicode'])\n  636              self.unicode_map = FileUnicodeMap()\n  637:             CMapParser(self.unicode_map, StringIO(strm.get_data())).run()\n  638          elif self.cidcoding == 'Adobe-Identity':\n  639              if ttf:\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\pdfminer\\cmapdb.py:\n  414          cmap = FileUnicodeMap()\n  415          #cmap = FileCMap()\n  416:         CMapParser(cmap, fp).run()\n  417          fp.close()\n  418          cmap.dump()\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\pdfminer\\layout.py:\n   19          elif isinstance(obj, LTTextGroup):\n   20              for x in obj:\n   21:                 self.run(x)\n   22          return\n   23  \n   ..\n  629          for group in groups:\n  630              group.analyze(laparams)\n  631:             assigner.run(group)\n  632          textboxes.sort(key=lambda box:box.index)\n  633          self._objs = textboxes + otherobjs + empties\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\pdfminer\\lzw.py:\n   95      \"\"\"\n   96      fp = StringIO(data)\n   97:     return ''.join(LZWDecoder(fp).run())\n   98  \n   99  if __name__ == '__main__':\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\pdfminer\\pdffont.py:\n  520              strm = stream_value(spec['ToUnicode'])\n  521              self.unicode_map = FileUnicodeMap()\n  522:             CMapParser(self.unicode_map, StringIO(strm.get_data())).run()\n  523          PDFFont.__init__(self, descriptor, widths)\n  524          return\n  ...\n  635              strm = stream_value(spec['ToUnicode'])\n  636              self.unicode_map = FileUnicodeMap()\n  637:             CMapParser(self.unicode_map, StringIO(strm.get_data())).run()\n  638          elif self.cidcoding == 'Adobe-Identity':\n  639              if ttf:\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\tools\\prof.py:\n   19          args.insert(0, argv[0])\n   20          prof = hotshot.Profile(prof)\n   21:         prof.runcall(lambda : func(args))\n   22          prof.close()\n   23      else:\n\nC:\\Users\\Taylor\\Documents\\GitHub\\dogshow\\Scraper\\libs\\pdfminer-20110515\\tools\\runapp.py:\n   20  \n   21      def do_POST(self):\n   22:         return self.run_cgi()\n   23  \n   24      def send_head(self):\n   25:         return self.run_cgi()\n   26  \n   27      def run_cgi(self):\n   ..\n   82          status = app.setup()\n   83          self.send_response(status, responses[status])\n   84:         app.run()\n   85          return\n   86  \n\n17 matches across 11 files\n",
			"settings":
			{
				"buffer_size": 170279,
				"line_ending": "Windows",
				"name": "Find Results",
				"scratch": true
			}
		},
		{
			"file": "showscraper.py",
			"settings":
			{
				"buffer_size": 8396,
				"line_ending": "Windows"
			}
		},
		{
			"file": "grammar.py",
			"settings":
			{
				"buffer_size": 845,
				"line_ending": "Windows"
			}
		},
		{
			"file": "parserunner.py",
			"settings":
			{
				"buffer_size": 2211,
				"line_ending": "Windows"
			}
		},
		{
			"file": "ringcleaner.py",
			"settings":
			{
				"buffer_size": 3811,
				"line_ending": "Windows"
			}
		},
		{
			"file": "cleaned/COUL1.pdf2txt.txt",
			"settings":
			{
				"buffer_size": 0,
				"line_ending": "Windows"
			}
		},
		{
			"file": "cleaned/GRMS1.pdf2txt.txt",
			"settings":
			{
				"buffer_size": 50580,
				"line_ending": "Unix"
			}
		},
		{
			"file": "model/show.py",
			"settings":
			{
				"buffer_size": 4912,
				"line_ending": "Windows"
			}
		},
		{
			"file": "util.py",
			"settings":
			{
				"buffer_size": 2136,
				"line_ending": "Windows"
			}
		},
		{
			"file": "driver.py",
			"settings":
			{
				"buffer_size": 131476,
				"line_ending": "Windows"
			}
		},
		{
			"file": "cleaned/BRAZ1.pdfbox.txt",
			"settings":
			{
				"buffer_size": 19820,
				"line_ending": "Windows"
			}
		},
		{
			"file": "config.py",
			"settings":
			{
				"buffer_size": 1164,
				"line_ending": "Windows"
			}
		},
		{
			"contents": "JUDGING PROGRAMS\nFifty-Ninth Annual All Breed Dog Shows, Obedience Trials & Rally Trials\nMember of the American Kennel Club\nCONFORMATION & OBEDIENCE - 2013100709  RALLY - 2013100710\nSATURDAY, NOVEMBER 9, 2013  Pages 6-7\nBEST PUPPY COMPETITION\nCONFORMATION & OBEDIENCE - 2013100714  RALLY - 2013100713\nSUNDAY, NOVEMBER 10, 2013  Pages 8-10\noMOTORHOME PARKING AVAILABLE WITH 30/50 AMP ELECTRICAL HOOKUPSo\nMinnesota Equestrian Center\n24621 Gilmore Valley Rd  Winona MN 55987\nRINGS ON FIRMLY PACKED DIRT\nSHOW HOURS  6:00 am to 6:00 pm\nTHESE SHOWS WILL BE HELD INDOORS - UNBENCHED\nOBEDIENCE CONTACT INFORMATION\nCELL NUMBERS\n(608) 213-7826  (651) 341-7755\nTHESE SHOWS ARE BEING HELD UNDER \nAMERICAN KENNEL CLUB \nRULES AND REGULATIONS\nJACK ONOFRIO DOG SHOWS, L.L.C.\n2ROUTES TO THE SHOW\nFROM I-90: Take Winona exit 252. Follow Hwy 43 north approximately 1.5 miles. Turn left (west) onto\nCounty Hwy 21 (Gilmore Vallay Rd) & travel approximately 1 mile. The Minnesota Equestrian Center will\nbe on your left.\nFROM HWY 61: Take Hwy 43 South (near Fleet Farm) for approximately 5 miles up the hill. Turn right\n(west) onto County Hwy 21 (Gilmore Valley Rd) & travel approximately 1 mile. The Minnesota Equestrian\nCenter will be on your left.\nGARMIN DEVICES DO NOT PROGRAM PROPERLY TO SITE.\nAKCs Event Cancellation Hotline: call (877) 252-3229 or visit\nakc.org to find information about cancellation of AKC Events.\n3SHOW VETERINARIAN\n(ON CALL)\nPet Medical Center\n57 East 3rd St, Winona MN\n(507) 454-2600\nwww.pmcwinona.com\nDirections to Vet: Head east on CO Hwy 21 toward CO Rd 44 (about 2 minutes). Take the 3rd left\nonto MN-43 N (about 7 minutes). Turn left onto Homer Rd. Continue onto Mankato Ave/Mankato\nAve Dike (about 2 minutes). Turn left onto 13th St/E Sarnia St (about 3 minutes). Turn right onto\nMain St (about 1 minute). Turn right onto W 4th St. Take the 1st left onto Center St. Take the 1st\nright onto E 3rd St. Destination will be on the right.\nNEW EXHIBITOR BRIEFING\nA new Exhibitor Briefing will be held 30 minutes prior to the published start of\njudging on Saturday. The briefing location will be posted at the Superintendents\ntable. Spectators are welcome to attend.\n4JUDGING PROGRAM BY ALPHABETICAL ORDER\nSAT SUN\nBREED RING TIME RING TIME\nAFGHAN 2 12:50 pm 3 12:40 pm\nAIREDALE 4 10:45 am 1 9:50 am\nAKITA 2 11:00 am 3 10:25 am\nALAS MAL 2 12:20 pm 3 12:40 pm\nAM STAFF 4 9:45 am 1 9:50 am\nAMER WATER SPN 1 10:40 am 2 10:20 am\nAUST SHEP 4 12:30 pm 4 8:00 am\nAUSTR CATTDOG 4 9:45 am 4 8:00 am\nBASSET 2 12:50 pm 3 11:55 am\nBEAGLE-13 IN 3 8:30 am 3 11:55 am\nBEAGLE-15 IN 3 8:30 am 3 11:55 am\nBERG PICARD 2 12:50 pm 1 11:50 am\nBERNS MTN 2 11:00 am 3 10:25 am\nBICHON 4 11:45 am 1 11:50 am\nBLOODHND 2 12:50 pm 3 12:40 pm\nBLUETICK 2 12:50 pm 3 12:40 pm\nBORDER COLL 4 12:30 pm 4 9:20 am\nBORDER TERR 4 11:45 am 1 10:50 am\nBOSTON TERR 3 9:30 am 1 8:00 am\nBOUV DES FLAN 4 10:45 am 4 12:40 pm\nBOXER 2 9:35 am 3 9:05 am\nBRITTANY 4 10:45 am 4 12:40 pm\nBRUSS GRIF 3 9:30 am 4 12:40 pm\nBULLDOG 4 8:30 am 1 8:00 am\nBULLMASTIFF 2 8:30 am 3 9:05 am\nCAIRN TERR 4 10:45 am 1 9:50 am\nCARD WELSH CORG 4 12:30 pm 4 9:20 am\nCAV KING CH 3 9:30 am 4 10:30 am\nCHES BAY RET 4 10:45 am 4 9:20 am\nCHIHUA LONG 3 9:30 am 4 10:30 am\nCHIHUA SMOOTH 3 8:30 am 4 9:20 am\nCHIN CREST 3 10:45 am 4 12:40 pm\nCHIN SHAR-PEI 4 8:30 am 1 9:00 am\nCKR SPN ASCOB 1 12:25 pm 2 12:50 pm\nCKR SPN BLACK 1 12:25 pm 2 12:50 pm\nCKR SPN PARTI 1 12:25 pm 2 12:50 pm\nCLUMBER SPN 1 12:25 pm 2 12:50 pm\nCOLL ROUGH 4 12:30 pm 4 9:20 am\nCOLL SMOOTH 4 12:30 pm\nCURLY COAT RET 1 10:40 am 2 9:05 am\nDACH SMOOTH 1 11:45 am 2 10:20 am\nDACH WIRE 1 11:45 am 2 10:20 am\nDALMATIAN 4 10:45 am 1 11:50 am\nDOBERMAN 2 8:30 am 3 9:05 am\nENG FOXHND 2 12:50 pm\nENG SETT 4 10:45 am 4 12:40 pm\nENG SPRINGER 1 10:40 am 2 9:05 am\nENGLISH COCKER 1 12:25 pm 2 10:20 am\nFLAT COAT RET 1 12:25 pm 2 12:50 pm\nFOX TER SMOOTH 4 10:45 am 1 9:50 am\nFOX TER WIRE 4 11:45 am 1 9:50 am\nFRENCH BULL 4 8:30 am 1 8:00 am\nGERM PIN 2 12:20 pm 3 12:40 pm\nGERM SHEPHERD 4 12:30 pm 4 8:00 am\nGERM SHT PNT 4 9:45 am 2 11:05 am\nGIANT SCHN 2 12:20 pm 3 12:40 pm\nGOLD RET 1 10:40 am 2 9:05 am\nGORD SETT 4 9:45 am 4 9:20 am\nGREAT DANE 2 8:30 am 3 8:00 am\nGREYHND 2 12:50 pm 3 11:55 am\nSAT SUN\nBREED RING TIME RING TIME\nGRT PYRENEES 2 12:20 pm 3 12:40 pm\nHAVANESE 3 12:30 pm 4 12:40 pm\nIRISH RED WHITE 4 10:45 am 4 12:40 pm\nIRISH WATER SPN 1 10:40 am 2 9:05 am\nIRISH WOLFHND 3 11:55 am\nJR SHOW NV IN 1 8:30 am 2 11:05 am\nJR SHOW NV JR 1 8:30 am 2 11:05 am\nJR SHOW OP IN 1 8:30 am 2 11:05 am\nJR SHOW OP JR 1 8:30 am 2 11:05 am\nJR SHOW OP SR 1 8:30 am 2 11:05 am\nKEESHOND 4 10:45 am 1 9:00 am\nKERRY BLUE 1 10:50 am\nLABRADOR 1 9:40 am 2 8:00 am\nLAKELND TERR 4 11:45 am 1 10:50 am\nLHASA 3 12:30 pm 1 9:00 am\nLOWCHEN 4 11:45 am 1 11:50 am\nMALTESE 3 12:30 pm 4 12:40 pm\nMIN SCHN 4 11:45 am 1 10:50 am\nMINI BULL TERR 4 11:45 am 1 10:50 am\nNEWF 2 9:35 am 3 10:25 am\nNORWICH TERR 1 10:50 am\nNOVA SCOTIA 1 12:25 pm 2 8:00 am\nOBED BEG NV A 5 11:55 am 5 11:30 am\nOBED BEG NV B 5 8:30 am 5 8:00 am\nOBED NV A 5 11:55 am 5 11:00 am\nOBED NV B 5 8:50 am 5 8:20 am\nOBED OP A 5 9:35 am 5 9:00 am\nOBED OP B 5 10:55 am 5 10:00 am\nOBED UT A 5 11:35 am 5 10:40 am\nOBED UT B 5 10:10 am 5 9:15 am\nOLD ENGLISH SHP 4 12:30 pm 4 12:40 pm\nPAPILLON 3 10:45 am 4 12:40 pm\nPEMB WELSH CORG 4 12:30 pm 4 10:30 am\nPOM 3 12:30 pm 4 12:40 pm\nPOOD MIN 3 12:30 pm 1 11:50 am\nPOOD STD 3 12:30 pm 1 11:50 am\nPOOD TOY 3 10:45 am 1 9:00 am\nPORT WATERDOG 2 12:20 pm 3 12:40 pm\nPRE OPEN 5 9:20 am 5 8:50 am\nPRE UTILITY 5 10:00 am\nPUG 3 8:30 am 3 8:00 am\nRALLY ADV A 5 12:50 pm 5 12:10 pm\nRALLY ADV B 5 12:50 pm 5 12:10 pm\nRALLY EX A 5 12:10 pm\nRALLY EX B 5 12:50 pm 5 12:10 pm\nRALLY NV A 5 12:50 pm 5 12:10 pm\nRALLY NV B 5 12:50 pm 5 12:10 pm\nREDBONE 2 12:50 pm 1 10:50 am\nRHORIDGE 2 12:50 pm 1 9:50 am\nROTTWEILER 2 9:35 am 3 9:05 am\nSALUKI 2 12:50 pm 1 10:50 am\nSAMOYED 2 11:00 am 3 10:25 am\nSCOTDEERHND 2 12:50 pm 1 10:50 am\nSCOTTISH TERR 1 9:50 am\nSHETLD SHEEP 4 12:30 pm 4 10:30 am\nSHIBA INU 4 11:45 am 1 8:00 am\nSHIH TZU 3 12:30 pm 4 12:40 pm\nSIB HUSKY 2 11:00 am 3 10:25 am\nSPINONE ITAL 1 9:40 am 4 8:00 am\nSTAF BULL 4 11:45 am 1 10:50 am\n5JUDGING PROGRAM BY ALPHABETICAL ORDER\nSAT SUN\nBREED RING TIME RING TIME\nSTD SCHN 2 11:00 am 3 12:40 pm\nTIB MASTIFF 2 12:20 pm 3 12:40 pm\nTIB TERR 4 11:45 am 1 9:00 am\nTOY FOX 3 8:30 am 4 10:30 am\nTREE WLKCOONHND 2 12:50 pm 1 10:50 am\nSAT SUN\nBREED RING TIME RING TIME\nVIZSLA 4 8:30 am 4 8:00 am\nWEIM 1 9:40 am 2 8:00 am\nWEL SPR SPN 1 9:40 am 2 9:05 am\nWHIPPET 2 12:50 pm 1 10:50 am\nJUDGES\nMrs Meghen Riese Bassel* ........................................................................481 Waddell Rd, Bremen GA 30110\nMs Joanne M Buehler* ....................................................................1 Turkey Foot Ct, Darnestown MD 20878\nMs Grace M Fritz..........................................................................................18135 Mission Rd, Stilwell KS 66085\nMrs Paula Hartinger ..........................................................................3548 Centurion Dr, Cincinnati OH 45211\nMr Roger R Hartinger .......................................................................3548 Centurion Dr, Cincinnati OH 45211\nMr Jason Hoke* ...........................................................................................1322 E Mifflin St, Madison WI 53703\nMr Charles W Kline...............................................................................4121 160th Ln NW, Andover MN 55304\nMs Linn Klingel-Brown*.....................................................1020 105th St W, Invergrove Heights MN 55077\nMrs Anna Lorenz....................................................................W6281 County Road FF, Elkhart Lake WI 53020\nDr Edna K Martin .....................................................................................6020 W Egidi Ln, Libertyville IL 60048\nMrs Rita J Rynder*................................................................................1328 Harlaxton Rd, Evansville IN 47725\nDr Bob G Smith* .............................................................................1916 Upperline St, New Orleans LA 70115\nMOTELS THAT WILL ACCEPT DOGS\nThe following motels will have blocks of rooms reserved until Ocotber 23, 2013. When making\nreservations, please inquire on additional fees for pets. Hotels in Winona are about 5 miles from\nShow Site; LaCrosse is about 30 miles from Show Site. PLEASE MAKE YOUR RESERVATIONS\nEARLY.\nTHE PLAZA HOTEL AND SUITES......................................................................................................(507) 453-0303\n1025 Highway 61E, Winona MN 55987\n$94.99 + tax  $25.00 1 time pet fee  10% off Green Mill\nEXPRESS SUITES RIVERPORT INN ...................................................................................................(507) 452-0606\n900 Bruski Dr, Winona MN 55987\n$89.99 + tax  $25.00 1 time pet fee  Breakfast included \nSTERLING MOTEL .................................................................................................................................(507) 454-1120\n1450 Gilmore Ave, Winona MN 55987\n$60.00 & up  $10.00 pet fee\nHOLIDAY INN EXPRESS & SUITES ...................................................................................................(507) 474-1700   \n1128 Homer Rd, Winona MN 55987\n$129.99 + tax  $25.00 per day pet fee  Continental Breakfast \nHOWARD JOHNSON (40 miles).......................................................................................................(608) 781-0400\n2150 Rose St, LaCrosse WI 54601\n$50.00 + tax  Breakfast & WIFI\nDAYS HOTEL & CONFERENCE CENTER (40 miles) ....................................................................... (608) 783-1000\n101 Sky Harbor Dr, LaCrosse WI 54601\n$75.00 + tax  Inquire about Pet Fee\nHOLIDAY INN EXPRESS (45 miles)..................................................................................................(608) 783-6555   \n9409 Hwy 16, Valley View Plaza, Onalaska WI 54650 \nCAMPGROUND  FOR WELL-BEHAVED DOGS\nPLAMOR CAMPGROUND & MARINA ................................................................................................(507) 454-2851\nPLEASE CLEAN UP AFTER YOUR DOGS\nRING 1\nDR BOB G SMITH (107)\n8:30 am\n4 Open Senior\n10 Open Intermediate\n5 Open Junior\n2 Novice Intermediate\n2 Novice Junior\n9:40 am\n6 Retrievers (Labrador) 2-1-2-0\n1 Veteran Dog\n9 Weimaraners 3-4-0-2\n4 Spinoni Italiani 1-0-1-2\n7 Spaniels (Welsh Springer) 0-2-2-2\n1 Veteran Dog\n10:40 am\n2 Retrievers (Curly-Coated) 0-1-0-0\n1 Veteran Dog\n2 Spaniels (American Water) 2-0-0-0\n8 Spaniels (Irish Water) 2-5-1-0\n2 Spaniels (English Springer) 1-0-0-1\n10 Retrievers (Golden) 6-2-1-1\nRING 1\nMS JOANNE M BUEHLER (6)\n11:45 am\n5 Dachshunds (Smooth) 2-2-0-1\n1 Dachshunds (Wirehaired) 1-0-0-0\nRING 1\nDR BOB G SMITH\n12:25 pm\n4 Spaniels (Cocker) Ascob 0-3-1-0\n10 Spaniels (English Cocker) 4-5-0-1\n2 Spaniels (Cocker) Black 0-1-1-0\n12 Retrievers (Nova Scotia Duck Tolling) 3-6-1-2\n1 Retrievers (Flat-Coated) 0-0-1-0\n1 Spaniels (Clumber) 0-0-1-0\n4 Spaniels (Cocker) Parti-Color 0-2-1-1\nRING 2\nMRS RITA J RYNDER (106)\n8:30 am\n2 Bullmastiffs 0-1-0-1\n11 Doberman Pinschers 4-3-3-1\n14 Great Danes 2-7-4-1\n9:35 am\n5 Rottweilers 1-2-2-0\n16 Boxers 8-6-0-2\n14 Newfoundlands 7-3-1-3\n11:00 am\n2 Akitas 0-1-0-0\n1 Veteran Dog\n4 Siberian Huskies 1-1-1-1\n6 Bernese Mountain Dogs 1-2-3-0\n12 Standard Schnauzers 5-2-3-2\n9 Samoyeds 2-5-0-2\n12:20 pm\n6 Giant Schnauzers 0-5-1-0\n1 German Pinschers 0-0-1-0\n1 Alaskan Malamutes 0-0-0-1\n1 Great Pyrenees 0-0-1-0\n1 Portuguese Water Dogs 0-1-0-0\n1 Tibetan Mastiffs 0-1-0-0\nRING 2\nMRS PAULA HARTINGER (44)\n12:50 pm\n6 Basset Hounds 1-3-1-1\n9 Whippets 3-2-3-1\n3 Scottish Deerhounds 2-1-0-0\n7 Rhodesian Ridgebacks 1-2-2-2\n10 Afghan Hounds 7-1-1-1\n1 Bluetick Coonhounds 0-1-0-0\n1 English Foxhounds 1-0-0-0\n1 Redbone Coonhounds 1-0-0-0\n1 Treeing Walker Coonhounds 0-0-1-0\n1 Greyhounds 0-0-0-1\n1 Bloodhounds 0-0-0-1\n1 Salukis 0-0-1-0\n2 Berger Picards (Misc. Dogs)\nRING 3\nMR JASON HOKE (138)\n8:30 am\n9 Pugs 2-6-1-0\n2 Beagles (13 Inch) 0-1-0-1\n5 Beagles (15 Inch) 2-0-3-0\n6 Chihuahuas (Smooth Coat) 2-2-1-1\n3 Toy Fox Terriers 0-0-1-2\n9:30 am\n3 Boston Terriers 0-0-2-1\n9 Chihuahuas (Long Coat) 4-1-2-2\n2 Brussels Griffons 0-0-1-1\n17 Cavalier King Charles Spaniels 3-6-4-4\n10:45 am\n2 Papillons 0-0-2-0\n5 Poodles (Toy) 1-3-0-1\n18 Chinese Cresteds 4-9-2-3\n11:45 am\nLUNCH\n12:30 pm\n8 Poodles (Standard) 1-5-1-1\n3 Shih Tzu 0-2-0-1\n10 Havanese 2-6-1-1\n18 Pomeranians 6-8-3-1\n1 Maltese 0-0-1-0\n3 Lhasa Apsos 2-0-0-1\n14 Poodles (Miniature) 4-6-2-2\nJUDGING PROGRAM\nThe number before each Breed (Variety) indicates the number of dogs entered in that Breed (Variety). The num-\nbers following each Breed (Variety) indicates the number of Regular Class Dogs, Regular Class Bitches, Best of\nBreed (Variety) (Dogs-Bitches).\nThere are 551 dogs entered in this show with a total of 583 entries plus 18 dogs and 25 entries in Rally.\n6\nSATURDAY, NOVEMBER 9, 2013\nRING 4\nMR ROGER R HARTINGER (101)\n8:30 am\n13 French Bulldogs 3-7-2-0\n1 Veteran Dog\n6 Bulldogs 2-3-0-1\n4 Chinese Shar-Pei 1-1-0-1\n1 Veteran Bitch\n8 Vizslas 2-3-0-3\n9:45 am\n2 American Staffordshire Terriers 1-0-1-0\n6 Australian Cattle Dogs 0-4-1-1\n14 Pointers (German Shorthaired) 6-3-3-2\n3 Setters (Gordon) 0-2-1-0\n10:45 am\n3 Retrievers (Chesapeake Bay) 2-1-0-0\n2 Keeshonden 0-0-2-0\n7 Airedale Terriers 2-4-1-0\n2 Bouviers des Flandres 1-0-1-0\n4 Setters (English) 2-0-1-1\n1 Brittanys 0-0-1-0\n1 Dalmatians 0-0-1-0\n1 Setters (Irish Red And White) 0-0-1-0\n2 Fox Terriers (Smooth) 0-0-0-2\n3 Cairn Terriers 1-1-0-1\n11:45 am\n2 Fox Terriers (Wire) 0-1-0-1\n2 Shiba Inu 0-2-0-0\n7 Tibetan Terriers 2-3-2-0\n2 Bichons Frises 0-0-1-1\n1 Lowchen 0-0-1-0\n1 Miniature Bull Terriers 0-0-1-0\n1 Border Terriers 1-0-0-0\n1 Lakeland Terriers 1-0-0-0\n1 Miniature Schnauzers 0-0-1-0\n1 Staffordshire Bull Terriers 0-1-0-0\nRING 4\nMS LINN KLINGEL-BROWN (54)\n12:30 pm\n4 Collies (Rough) 3-1-0-0\n11 Australian Shepherds 4-4-3-0\n6 German Shepherd Dogs 2-2-2-0\n2 Old English Sheepdogs 0-1-0-1\n10 Border Collies 3-6-0-1\n1 Collies (Smooth) 0-1-0-0\n6 Pembroke Welsh Corgis 2-3-1-0\n7 Shetland Sheepdogs 2-4-1-0\n7 Cardigan Welsh Corgis 0-3-2-2\nGROUP RING\n2:15 pm\nVARIETY GROUP JUDGING\nSPORTING GROUP - MRS PAULA HARTINGER\nHOUND GROUP - MR ROGER R HARTINGER\nTERRIER GROUP - MRS PAULA HARTINGER\nWORKING GROUP - MR ROGER R HARTINGER\nHERDING GROUP - MRS PAULA HARTINGER\nTOY GROUP - MR ROGER R HARTINGER\nNON-SPORTING GROUP - MRS PAULA HARTINGER\nBEST IN SHOW - MRS PAULA HARTINGER\nUnless otherwise announced by 1:45 pm\nPUPPY GROUPS: Ring & Time to be announced\n7\nSATURDAY, NOVEMBER 9, 2013\nRING 1\nMS GRACE M FRITZ (74)\n8:00 am\n3 Boston Terriers 0-0-2-1\n13 French Bulldogs 3-7-2-0\n1 Veteran Dog\n3 Shiba Inu 0-3-0-0\n7 Bulldogs 3-3-0-1\n9:00 am\n4 Chinese Shar-Pei 1-1-0-1\n1 Veteran Bitch\n2 Keeshonden 0-0-2-0\n3 Poodles (Toy) 1-1-0-1\n7 Tibetan Terriers 2-3-2-0\n3 Lhasa Apsos 2-0-0-1\nRING 1\nDR EDNA K MARTIN (49)\n9:50 am\n7 Rhodesian Ridgebacks 1-2-2-2\n2 American Staffordshire Terriers 1-0-1-0\n7 Airedale Terriers 1-5-1-0\n2 Fox Terriers (Smooth) 0-0-0-2\n3 Cairn Terriers 1-1-0-1\n2 Scottish Terriers 1-0-1-0\n2 Fox Terriers (Wire) 0-1-0-1\n10:50 am\n3 Miniature Schnauzers 0-2-1-0\n11 Whippets 3-3-2-3\n1 Miniature Bull Terriers 0-0-1-0\n1 Border Terriers 1-0-0-0\n1 Norwich Terriers 0-0-1-0\n1 Lakeland Terriers 1-0-0-0\n1 Staffordshire Bull Terriers 0-1-0-0\n1 Kerry Blue Terriers 0-0-0-1\n1 Redbone Coonhounds 1-0-0-0\n1 Treeing Walker Coonhounds 0-0-1-0\n1 Salukis 0-0-1-0\n1 Scottish Deerhounds 1-0-0-0\nRING 1\nMS GRACE M FRITZ\n11:50 am\n13 Poodles (Miniature) 4-5-2-2\n2 Bichons Frises 0-0-1-1\n1 Lowchen 0-0-1-0\n2 Berger Picards (Misc. Dogs)\n1 Dalmatians 0-0-1-0\n10 Poodles (Standard) 3-5-1-1\nRING 2\nMRS MEGHEN RIESE BASSEL (91)\n8:00 am\n9 Weimaraners 3-4-0-2\n6 Retrievers (Labrador) 2-1-2-0\n1 Veteran Dog\n12 Retrievers (Nova Scotia Duck Tolling) 3-6-1-2\n9:05 am\n8 Spaniels (Welsh Springer) 1-2-2-2\n1 Veteran Dog\n2 Retrievers (Curly-Coated) 0-1-0-0\n1 Veteran Dog\n3 Spaniels (English Springer) 1-0-1-1\n11 Retrievers (Golden) 6-4-1-0\n8 Spaniels (Irish Water) 2-5-1-0\n10:20 am\n2 Spaniels (American Water) 2-0-0-0\n10 Spaniels (English Cocker) 4-5-0-1\n5 Dachshunds (Smooth) 2-2-0-1\n1 Dachshunds (Wirehaired) 1-0-0-0\nRING 2\nMR JASON HOKE (38)\n11:05 am\n15 Pointers (German Shorthaired) 6-4-3-2\n4 Open Senior\n10 Open Intermediate\n5 Open Junior\n2 Novice Intermediate\n2 Novice Junior\nRING 2\nMRS MEGHEN RIESE BASSEL\n12:50 pm\n4 Spaniels (Cocker) Parti-Color 0-2-1-1\n4 Spaniels (Cocker) Ascob 0-3-1-0\n1 Retrievers (Flat-Coated) 0-0-1-0\n1 Spaniels (Clumber) 0-0-1-0\n4 Spaniels (Cocker) Black 0-1-2-1\nRING 3\nMR ROGER R HARTINGER (132)\n8:00 am\n9 Pugs 2-6-1-0\n18 Great Danes 5-8-4-1\nJUDGING PROGRAM\nThe number before each Breed (Variety) indicates the number of dogs entered in that Breed (Variety). The num-\nbers following each Breed (Variety) indicates the number of Regular Class Dogs, Regular Class Bitches, Best of\nBreed (Variety) (Dogs-Bitches).\nOFFICIAL NOTICE: Additional Judges.\nReference Chapter 7, Section 13 of AKC Rules: Owner has the right to withdraw his entry and have his entry fee\nrefunded provided notification of his withdrawal is received no later than one half-hour prior to the start of any\nregular conformation judging.\nMr Jason Hoke will judge Pointers (German Shorthaired) and Mr Roger R Hartinger will judge Pugs in place of\nMrs Paula Hartinger.\nThere are 570 dogs entered in this show with a total of 602 entries plus 15 dogs and 20 entries in Rally.\n8\nSUNDAY, NOVEMBER 10, 2013\n9:05 am\n2 Bullmastiffs 0-1-0-1\n5 Rottweilers 1-2-2-0\n16 Boxers 8-6-0-2\n11 Doberman Pinschers 4-3-3-1\n10:25 am\n3 Siberian Huskies 1-1-1-0\n2 Akitas 0-1-0-0\n1 Veteran Dog\n4 Bernese Mountain Dogs 1-0-2-0\n1 Veteran Bitch\n15 Newfoundlands 8-3-1-3\n13 Samoyeds 3-8-0-2\nRING 3\nMS JOANNE M BUEHLER (17)\n11:55 am\n6 Basset Hounds 1-3-1-1\n2 Beagles (13 Inch) 0-1-0-1\n3 Irish Wolfhounds 1-2-0-0\n1 Greyhounds 0-0-0-1\n5 Beagles (15 Inch) 2-0-3-0\nRING 3\nMR ROGER R HARTINGER\n12:40 pm\n6 Giant Schnauzers 0-5-1-0\n9 Afghan Hounds 6-1-1-1\n12 Standard Schnauzers 5-2-3-2\n1 German Pinschers 0-0-1-0\n1 Bloodhounds 0-0-0-1\n1 Bluetick Coonhounds 0-1-0-0\n1 Alaskan Malamutes 0-0-0-1\n1 Great Pyrenees 0-0-1-0\n1 Portuguese Water Dogs 0-1-0-0\n1 Tibetan Mastiffs 0-1-0-0\nRING 4\nMRS PAULA HARTINGER (175)\n8:00 am\n6 Australian Cattle Dogs 0-4-1-1\n11 German Shepherd Dogs 4-5-2-0\n7 Vizslas 2-3-0-2\n4 Spinoni Italiani 1-0-1-2\n10 Australian Shepherds 3-4-3-0\n9:20 am\n10 Border Collies 3-6-0-1\n5 Collies (Rough) 4-1-0-0\n3 Retrievers (Chesapeake Bay) 2-1-0-0\n3 Setters (Gordon) 0-2-1-0\n7 Cardigan Welsh Corgis 0-3-2-2\n6 Chihuahuas (Smooth Coat) 2-2-1-1\n10:30 am\n3 Toy Fox Terriers 0-0-1-2\n6 Pembroke Welsh Corgis 2-3-1-0\n8 Chihuahuas (Long Coat) 4-1-2-1\n7 Shetland Sheepdogs 2-4-1-0\n17 Cavalier King Charles Spaniels 3-6-4-4\n11:55 am\nLUNCH\n12:40 pm\n2 Old English Sheepdogs 0-1-0-1\n2 Bouviers des Flandres 1-0-1-0\n3 Setters (English) 1-0-1-1\n1 Brittanys 0-0-1-0\n1 Setters (Irish Red And White) 0-0-1-0\n2 Papillons 0-0-2-0\n2 Brussels Griffons 0-0-1-1\n2 Shih Tzu 0-1-0-1\n17 Chinese Cresteds 4-9-2-2\n1 Maltese 0-0-1-0\n19 Pomeranians 7-8-3-1\n10 Havanese 2-6-1-1\n45 minute Lunch Break at judges discretion\nGROUP RING\n1:30 pm\nVARIETY GROUP JUDGING\nSPORTING GROUP - DR BOB G SMITH\nHERDING GROUP - MR ROGER R HARTINGER\nNON-SPORTING GROUP - MR ROGER R HARTINGER\nHOUND GROUP - MRS PAULA HARTINGER\nWORKING GROUP - MRS PAULA HARTINGER\nTERRIER GROUP - MR ROGER R HARTINGER\nTOY GROUP - MR JASON HOKE\nBEST IN SHOW - DR EDNA K MARTIN\nUnless otherwise announced by 1:00 pm\nOWNER-HANDLED GROUPS: Ring, Time & Order to\nbe announced\n10\nSUNDAY, NOVEMBER 10, 2013\n11\nTHREE HEALTH CLINICS\n9:00 am - 2:00 pm for all clinics\nSaturday, November 9, 2013\nHeld in conjunction with Coulee Kennel Club, Inc.\nPlease check www.couleekennelclub.org for additional details.\nBAER HEARING TEST CLINIC \nRick Miller  Rochester MN\nFEE: $45.00 for OFA Certification Form\n$35.00 Without OFA Form\nMinimum Age 8 Weeks  No Litter Rate\nCARDIAC CLINIC \nDr Chris Stauthammer, DMV DACVIM (Cardiology)\nFEE: $35.00\nSunday, November 10, 2013\nCERF\nDr Jim Schoster DVM DACVO\nFEE: $35.00\nNeed to bring registered name, registration number, whelp date and\npermanent ID number \nQuestions/Pre-Registration for clinics\nContact: Kim Maret - 1776 Birch Hollow Rd, Decorah IA 52101\n(414) 975-9153  kjmaret@aol.com\nBREED(S): ...............................................................................................................................\nNAME(S) OF DOGS: ...............................................................................................................\nOWNERS NAME: ....................................................................................................................\nPHONE: ...................................................................................................................................\nEMAIL: ....................................................................................................................................\nCHECK WHICH CLINIC        BAER        ? Cardiac   ? CERF   ?\nSPECIFY WHAT BREEDS ARE EXHIBITING OR APPOINTMENT TIME PREFERENCE\n................................................................................................................................................\nMake checks payable to: Coulee Kennel Club, Inc.\nDogs do not have to be entered at the show to participte in Health Clinics.\n12\nAll Breed Sanctioned B-Match\nSaturday, November 9, 2013\nMinnesota Equestrian Center, Winona MN\n$25.00 Onofrio Gift Certifcate to Match BIS\n(Gift Certificate is through Jack Onofrio Dog Shows, L.L.C. to be used towards \nSHOW ENTRIES for any dog show for which Onofrio is the Superintendent)\nsponsored by Julia Crawford\nJudging to start 1/2 hour after Best in Show\nNo pre-entries\nEntries will be taken Saturday, November 9\nuntil start of Best in Show\nDay of Show Entry Fee: $8.00\nJudges will be announced the day of the Match\nCONFORMATION CLASSES\nPuppy:  3-6, 6-9 & 9-12 months\nAdult :  Open\nPuppies will not compete against adults\nMajor pointed dogs may not compete\nProfessional handlers may only show dogs owned by them\nJUNIOR SHOWMANSHIP\nPee Wee up to 9 Years  Novice Jr  Novice Int  Novice Sr\nOpen Jr  Open Int  Open Sr \nAdult Showmanship to be judged by Best Junior\nOBEDIENCE RUN-THROUGHS ONLY OFFERED\n$5.00/5 minutes\n2nd run-throughs only after 1st run-throughs completed \n& no later than 9:00 pm\nMatch Chair, Julia Crawford\nMatch Secretary, Kristen Everson\nSend inquiries to:\nKristen Everson  N3039 Welch Coulee Rd, LaCrosse WI 54601\neverson.Kris@hotmail.com\n",
			"file": "cleaned/COUL1.pdfbox.txt",
			"file_size": 21437,
			"file_write_time": 130277464781212908,
			"settings":
			{
				"buffer_size": 22463,
				"line_ending": "Unix"
			}
		},
		{
			"file": "parsed/COUL1.pdfbox.txt",
			"settings":
			{
				"buffer_size": 0,
				"line_ending": "Windows"
			}
		},
		{
			"file": "/C/Users/Taylor/Documents/GitHub/dogshow/grammar/ANTLR/bin/README.txt",
			"settings":
			{
				"buffer_size": 106,
				"line_ending": "Windows"
			}
		}
	],
	"build_system": "",
	"command_palette":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"console":
	{
		"height": 125.0
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"file_history":
	[
		"/C/Users/Taylor/Documents/GitHub/dogshow/Scraper/demo.py",
		"/C/Users/Taylor/Documents/GitHub/dogshow/Scraper/json/GRMS1.pdfbox.json",
		"/C/Users/Taylor/Documents/GitHub/dogshow/Scraper/json/COUL1.pdfbox.json",
		"/C/Users/Taylor/Documents/GitHub/dogshow/Scraper/cleaned/COUL1.pdfbox.txt",
		"/C/Users/Taylor/Documents/GitHub/dogshow/Scraper/cleaned/GRMS1.pdfbox.txt",
		"/C/Users/Taylor/Documents/GitHub/dogshow/Scraper/cleaned/COUL1.pdf2txt.txt",
		"/C/Users/Taylor/Documents/GitHub/dogshow/Scraper/cleaned/GRMS1.pdf2txt.txt",
		"/C/Users/Taylor/Documents/GitHub/dogshow/Scraper/parsed/GRMS1.pdf2txt.txt",
		"/C/Users/Taylor/Documents/GitHub/dogshow/Scraper/parsed/GRMS1.pdfbox.txt",
		"/C/Users/Taylor/Documents/GitHub/dogshow/Scraper/ringcleaner.py",
		"/C/Users/Taylor/Documents/GitHub/dogshow/Scraper/model/show.py",
		"/C/Users/Taylor/Documents/GitHub/dogshow/Scraper/config.py",
		"/C/Users/Taylor/Documents/GitHub/dogshow/Scraper/parserunner.py",
		"/C/Users/Taylor/Documents/GitHub/dogshow/Scraper/cleaned/GRMS1.pdf",
		"/C/Users/Taylor/Documents/GitHub/dogshow/Scraper/grammar.py",
		"/C/Users/Taylor/Documents/GitHub/dogshow/Scraper/driver.py",
		"/C/Users/Taylor/SkyDrive/Public/myout.txt",
		"/C/Users/Taylor/Documents/GitHub/dogshow/Scraper/showscraper.py",
		"/C/Users/Taylor/Documents/GitHub/dogshow/Scraper/dogshowprogramworker.py",
		"/C/Users/Taylor/Documents/GitHub/dogshow/Scraper/parsed/dogshowprogramworker",
		"/C/Users/Taylor/Documents/GitHub/dogshow/Scraper/scraper.py",
		"/C/Users/Taylor/Documents/GitHub/dogshow/Scraper/local/closedshows.htm",
		"/C/Users/Taylor/Documents/GitHub/dogshow/Scraper/parsed/pdf2txt_ANOK1JP.txt",
		"/C/Users/Taylor/Documents/GitHub/dogshow/Scraper/programcleaner.py",
		"/C/Users/Taylor/Documents/GitHub/dogshow/Scraper/util.py",
		"/C/Users/Taylor/Desktop/pdfminer/dist/pdfminer-20110515/README.txt",
		"/C/Users/Taylor/Desktop/pdfminer/dist/pdfminer-20110515/tools/pdf2txt.py",
		"/C/Users/Taylor/Desktop/ANOK1JP.txt",
		"/C/Users/Taylor/Documents/GitHub/dogshow/grammar/PDF-Parsing/PLUM1JP.txt",
		"/C/Users/Taylor/Documents/GitHub/dogshow/grammar/PDF-Parsing/SACS1JP.txt",
		"/C/Users/Taylor/Documents/GitHub/dogshow/Scraper/cleaned/KTDC1JP.txt",
		"/C/Users/Taylor/Documents/GitHub/dogshow/Scraper/parsed/ANOK1JP.txt",
		"/C/Users/Taylor/Documents/GitHub/dogshow/grammar/PDF-Parsing/TRIN1JP.txt",
		"/C/Users/Taylor/Documents/GitHub/dogshow/Scraper/location.py",
		"/C/Users/Taylor/Documents/GitHub/dogshow/Scraper/show.py",
		"/C/Users/Taylor/Documents/GitHub/dogshow/Scraper/showutils.py",
		"/C/Users/Taylor/Documents/Download.txt",
		"/C/Users/Taylor/Documents/wedding-thankyou",
		"/C/Users/Taylor/Documents/GitHub/dogshow/android/MyDogshow/gradle/wrapper/gradle-wrapper.properties",
		"/C/Users/Taylor/Documents/GitHub/dogshow/android/MyDogshow/local.properties",
		"/C/Users/Taylor/Documents/GitHub/MyApplicationProject/local.properties",
		"/C/Users/Taylor/Documents/GitHub/dogshow/android/MyDogshow/project.properties",
		"/C/Users/Taylor/Documents/Jessica/Blue-Return-Address.avery",
		"/C/Users/Taylor/Documents/GitHub/BlankProject/.idea/scopes/scope_settings.xml",
		"/C/Users/Taylor/Documents/GitHub/BlankProject/build.gradle",
		"/C/Users/Taylor/Documents/GitHub/dogshow/android/MyDogshow/build.gradle",
		"/C/Users/Taylor/Desktop/Raikes/2011/Spring 2011/W1.txt",
		"/C/Users/Taylor/Documents/iTunes.txt",
		"/C/Users/Taylor/Documents/AndroidUX",
		"/C/Users/Taylor/Documents/Lee Griffin - IBM.txt",
		"/C/Users/Taylor/Documents/GitHub/dogshow/Scraper/retry_decorator.py",
		"/C/Users/Taylor/Documents/GitHub/dogshow/Scraper/appserver_accessor.py",
		"/C/Users/Taylor/Documents/GitHub/dogshow/android/JakeWharton-ActionBarSherlock-e5c2d1c/.idea/libraries/android_support_v42.xml",
		"/C/Users/Taylor/workspace/AssurityAlert/res/layout/empty_message_list.xml",
		"/C/Users/Taylor/workspace/AssurityAlert/src/com/assurity/alertcenter/ui/MessageListFragment.java",
		"/C/Users/Taylor/Documents/GitHub/dogshow/android/MyDogshow/store.keystore",
		"/C/Users/Taylor/Documents/GitHub/dogshow/android/MyDogshow/.idea/workspace.xml",
		"/C/Users/Taylor/Documents/GitHub/dogshow/android/MyDogshow/src/dev/tnclark8012/dogshow/apps/android/provider/PersistHelper.java",
		"/C/Program Files (x86)/Android/android-sdk/extras/android/support/README.txt",
		"/C/Users/Taylor/workspace/AssurityAlert/src/com/assurity/alertcenter/ui/dialog/WaitDialogFragment.java",
		"/C/Users/Taylor/AppData/Local/GitHub/shell.ps1",
		"/C/Users/Taylor/Documents/GitHub/dogshow/android/MyDogshow/src/dev/tnclark8012/dogshow/apps/android/ui/ShowSetupActivity.java",
		"/C/Users/Taylor/Documents/GitHub/dogshow/DogshowServer/src/dev/tclark/dogshow/ShowRingServlet.java",
		"/C/Users/Taylor/Documents/GitHub/dogshow/DogshowServer/src/dev/tclark/dogshow/ShowServlet.java",
		"/C/Users/Taylor/Documents/GitHub/dogshow/android/MyDogshow/res/layout/fragment_entry_dogs.xml",
		"/C/Users/Taylor/Documents/GitHub/dogshow/grammar/ANTLR/test.g",
		"/C/Users/Taylor/Documents/GitHub/dogshow/Scraper/parsed/MINN1JP.txt",
		"/C/Users/Taylor/Documents/GitHub/dogshow/Scraper/programs/ANOK1JP.txt",
		"/C/Users/Taylor/Documents/GitHub/dogshow/Scraper/out.txt",
		"/C/Users/Taylor/Documents/GitHub/dogshow/README.md",
		"/C/Users/Taylor/Documents/GitHub/dogshow/grammar/grammar/testParser.java",
		"/C/Users/Taylor/Documents/GitHub/dogshow/DogshowServer/src/dev/tclark/dogshow/persistence/datastore/ShowRing.java",
		"/C/Users/Taylor/Documents/GitHub/dogshow/DogshowShared/.classpath",
		"/C/Users/Taylor/Documents/GitHub/dogshow/android/MyDogshow/src/dev/tnclark8012/dogshow/apps/android/ui/MyScheduleFragment.java",
		"/C/Users/Taylor/Documents/GitHub/dogshow/DogshowServer/src/dev/tclark/dogshow/persistence/datastore/Show.java",
		"/C/Users/Taylor/Desktop/log.txt",
		"/C/Users/Taylor/Desktop/Raikes/2013/Algorithms/HW2/homework2.tex",
		"/C/Users/Taylor/Documents/WindowsPowerShell/Microsoft.PowerShell_profile.ps1",
		"/C/Users/Taylor/Documents/GitHub/dogshow/gwlafspi.a21.txt",
		"/C/Users/Taylor/Documents/GitHub/dogshow/android/JakeWharton-ActionBarSherlock-e5c2d1c/library/.gitignore",
		"/C/Users/Taylor/Documents/GitHub/dogshow/Scraper/local/showpage.htm",
		"/C/Users/Taylor/workspace/Python/scrapping/config.py",
		"/C/Users/Taylor/Documents/GitHub/dogshow/grammar/JavaTest/src/dev/tclark/dogshow/grammar/testLexer.java",
		"/C/Users/Taylor/Documents/GitHub/dogshow/.gitignore",
		"/C/Users/Taylor/Documents/GitHub/dogshow/grammar/ANTLR/output/dogshowcomboParser.java",
		"/C/Users/Taylor/Documents/GitHub/dogshow/grammar/ANTLR/output/dogshowcomboLexer.java",
		"/C/Users/Taylor/Documents/GitHub/dogshow/Scraper/parsed/KTDC1JP.txt",
		"/C/Users/Taylor/Documents/GitHub/dogshow/Scraper/.gitignore",
		"/C/Users/Taylor/Documents/GitHub/dogshow/DogshowServer/war/WEB-INF/.gitignore",
		"/C/Users/Taylor/workspace/Python/scrapping/parsed/TDTC1JP.txt",
		"/C/Users/Taylor/workspace/Python/scrapping/parserunner.py",
		"/C/Users/Taylor/workspace/Python/scrapping/driver.py",
		"/C/Users/Taylor/workspace/Python/scrapping/show.py",
		"/C/Users/Taylor/workspace/Python/scrapping/scraper.py",
		"/C/Users/Taylor/workspace/Python/scrapping/showutils.py",
		"/C/Users/Taylor/Documents/GitHub/dogshow/grammar/JavaTest/.gitignore",
		"/C/Users/Taylor/Documents/GitHub/dogshow/grammar/JavaTest/.classpath",
		"/C/Users/Taylor/Documents/GitHub/dogshow/grammar/JavaTest/testcase/examples/LEAV1JP.txt",
		"/C/Users/Taylor/workspace/Python/scrapping/New Text Document.txt",
		"/C/Users/Taylor/Documents/GitHub/dogshow/grammar/PDF-Parsing/README.md",
		"/C/Users/Taylor/workspace/Python/scrapping/retry_decorator.py",
		"/C/Users/Taylor/workspace/Python/scrapping/local/showpage.htm",
		"/C/Users/Taylor/workspace/Python/scrapping/Show.py",
		"/C/Users/Taylor/workspace/Python/scrapping/demo.py",
		"/C/Users/Taylor/Desktop/Raikes/2013/CS 311/Homework 5/akoch/akoch5.py",
		"/C/Users/Taylor/Desktop/Raikes/2013/CS 311/Homework 5/record",
		"/C/Users/Taylor/Desktop/Raikes/2013/CS 311/Homework 5/mazes/mazefile5.txt",
		"/C/Users/Taylor/Desktop/Raikes/2013/CS 311/Homework 5/mazes/mazefile1.txt",
		"/C/Users/Taylor/Desktop/jersey-archive-1.17/jersey-archive-1.17/testrules.txt",
		"/C/Users/Taylor/Documents/GitHub/dogshow/.git/rebase-apply/patch",
		"/C/Users/Taylor/Documents/GitHub/dogshow/grammar/JavaTest/src/dev/tclark/dogshow/grammar/test/LexerTest.java",
		"/C/Users/Taylor/Documents/GitHub/dogshow/grammar/JavaTest/src/testParser.java",
		"/C/Users/Taylor/Desktop/Raikes/2013/CS 311/Homework 5/rmead/readme.txt",
		"/C/Users/Taylor/Desktop/Raikes/2013/CS 311/Homework 5/mbravo/mbravo5.py",
		"/C/Users/Taylor/Documents/GitHub/dogshow/Libraries/objectify-3.1/edit-this-to-build.properties",
		"/C/Users/Taylor/Documents/GitHub/dogshow/android/UI-Design/Android_Design_Color_Swatches/Android_Design_Color_Swatches_20120229/values.txt",
		"/C/Users/Taylor/workspace/AssurityAlert/src/com/assurity/alertcenter/util/MessageListActionMode.java",
		"/C/Users/Taylor/Documents/GitHub/dogshow/grammar/JavaTest/testcase/PLUM1JP.txt",
		"/C/Users/Taylor/Documents/GitHub/dogshow/grammar/JavaTest/testcase/TRIN1JP.txt",
		"/C/Users/Taylor/workspace/AssurityAlert/src/com/assurity/alertcenter/adapters/MessageOverviewArrayAdapter.java",
		"/C/Users/Taylor/workspace/AssurityAlert/src/com/assurity/alertcenter/adapters/RequirementArrayAdapter.java",
		"/C/Users/Taylor/workspace/AssurityAlert/src/com/assurity/alertcenter/registration/RegistrationActivity.java",
		"/C/Users/Taylor/workspace/AssurityAlert/src/com/assurity/alertcenter/ui/HomeActivity.java",
		"/C/Users/Taylor/Documents/GitHub/dogshow/grammar/JavaTest/testcase/SACS1JP.txt",
		"/C/Users/Taylor/Documents/GitHub/dogshow/android/UI-Design/Android_Design_Color_Swatches/Android_Design_Color_Swatches_20120229/NOTICE.txt",
		"/C/Users/Taylor/workspace/AssurityAlert/src/com/assurity/alertcenter/adapters/MessageListSpinnerAdapter.java",
		"/C/Users/Taylor/workspace/AssurityAlert/src/com/assurity/alertcenter/adapters/MessageModelAdapter.java",
		"/C/Users/Taylor/workspace/AssurityAlert/src/com/assurity/alertcenter/registration/SetupActivity.java"
	],
	"find":
	{
		"height": 34.0
	},
	"find_in_files":
	{
		"height": 0.0,
		"where_history":
		[
			"*.py",
			""
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			".run",
			"print(",
			"_pullshow",
			"adding da",
			"datepairs",
			"searching",
			"showlimit",
			"getshowdetails",
			"pullshow(",
			"pullshow",
			"getshowdetails",
			".code =",
			".code",
			"downloadprogram",
			"did not download",
			"downloadprogram",
			"setting pdf",
			"edna k",
			"to follow",
			"5 utility",
			"lorenz",
			"novice a",
			"rally ",
			"(25)",
			"utility a class",
			"\\d+(-\\d+)?(;\\d+(-\\d+)?)*",
			"rally",
			"\\d+-\\d+$",
			"beginner",
			"\\d+ (;\\d+(-\\d+)?)",
			"goes to",
			".* goes to ",
			"rally",
			"ring \\d+",
			"parseProgramPdf2Txt",
			"reading from file",
			"moves to",
			"assigndates",
			"collected show JSON",
			"after split",
			"cleanPdf2Txt",
			"moves to ring",
			"Ring \\d+",
			"lines after ",
			"_parseCompanionShows",
			"woot",
			"WOOT",
			"couldn't get json",
			"RINGS_AND_DATES",
			"showcount",
			"pullShow",
			"getShowDetails",
			"pullShow",
			"companion",
			".date",
			"companionShow",
			"parsestartdate",
			"companionshow",
			"mktime",
			"_parseSta",
			"_parsesta",
			"PARSECOM",
			"companion",
			"(\"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\")\n",
			"assigndates",
			"rings'",
			"rings",
			".pdflink",
			"download",
			"Ring \\d+",
			"ring \\d+",
			"\"]}}}]}",
			"ring \\d+",
			"rally",
			"clean",
			"getringdates",
			"_getDateRingMap",
			"lines after",
			"ThatsAll",
			"rally",
			"all",
			"self.clean",
			"parseProgramPdf2Txt",
			"getshowjson",
			"getShowJson",
			"popen",
			"subproc",
			"pdfbox.",
			"pdf.json",
			"pdf.",
			"jsonfile",
			"open(",
			"with",
			"jsonobj",
			"getdate",
			"collectrin",
			"collectrings",
			"parseshowjson",
			"getShowJson",
			"getshowjson",
			"getShowJson",
			"subprocess",
			"parseProgramPdfBox",
			"parseShowJson",
			"getShowJson",
			"pdfbox-app",
			"isfile",
			"getRingDates",
			"collectringdates",
			"collectRingDates",
			"_getDateRingMap",
			"+ \" rings\"",
			"+ \"rings\"",
			"found",
			"grammar",
			"getshowjson",
			"did not down",
			"did not download the ",
			"config.",
			"config",
			"pullclosed",
			"get closed show",
			"++",
			"group",
			"obj.",
			"obj/",
			"obj.",
			"obj"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
			"",
			"-",
			"",
			"Pdf.DOWNLOAD_DIR",
			"AppServer.SHOW_POST_URL",
			"AppServer.SERVER_URL",
			"config.Env.DO_DOWNLOAD",
			"config.Env.VERBOSE",
			"config.Env.OFFLINE",
			"config.",
			"VERBOSE",
			"2009070100",
			"2009070300",
			"2009070200",
			"'|\\n",
			"print(\"",
			"print(",
			"and",
			"ghostReplacement",
			"'ghostReplacement",
			"subMiddleList",
			"'"
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 11,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "dogshowprogramworker.py",
					"settings":
					{
						"buffer_size": 9919,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 1,
					"settings":
					{
						"buffer_size": 170279,
						"regions":
						{
							"match":
							{
								"flags": 112,
								"regions":
								[
									[
										199,
										211
									],
									[
										564,
										576
									],
									[
										873,
										885
									],
									[
										1220,
										1231
									],
									[
										1654,
										1673
									],
									[
										2210,
										2227
									],
									[
										2571,
										2590
									],
									[
										2896,
										2915
									],
									[
										3234,
										3245
									],
									[
										3497,
										3508
									],
									[
										3879,
										3895
									],
									[
										4167,
										4183
									],
									[
										4492,
										4497
									],
									[
										4725,
										4730
									],
									[
										4767,
										4772
									],
									[
										5023,
										5028
									],
									[
										5225,
										5230
									],
									[
										5336,
										5341
									],
									[
										5350,
										5355
									],
									[
										5577,
										5582
									],
									[
										5600,
										5605
									],
									[
										5777,
										5782
									],
									[
										5966,
										5971
									],
									[
										5989,
										5994
									],
									[
										6061,
										6066
									],
									[
										6268,
										6273
									],
									[
										6442,
										6447
									],
									[
										6457,
										6462
									],
									[
										6495,
										6500
									],
									[
										6552,
										6557
									],
									[
										6822,
										6827
									],
									[
										7127,
										7132
									],
									[
										7138,
										7143
									],
									[
										7516,
										7521
									],
									[
										7721,
										7726
									],
									[
										7736,
										7741
									],
									[
										7960,
										7965
									],
									[
										8237,
										8242
									],
									[
										8619,
										8624
									],
									[
										8904,
										8909
									],
									[
										8915,
										8920
									],
									[
										9281,
										9286
									],
									[
										9460,
										9465
									],
									[
										9475,
										9480
									],
									[
										9683,
										9688
									],
									[
										9935,
										9940
									],
									[
										10132,
										10137
									],
									[
										10417,
										10422
									],
									[
										10566,
										10571
									],
									[
										10839,
										10844
									],
									[
										11120,
										11125
									],
									[
										11231,
										11236
									],
									[
										11245,
										11250
									],
									[
										11482,
										11487
									],
									[
										11509,
										11514
									],
									[
										11738,
										11743
									],
									[
										11785,
										11790
									],
									[
										11974,
										11979
									],
									[
										12321,
										12326
									],
									[
										12342,
										12347
									],
									[
										12420,
										12425
									],
									[
										12433,
										12438
									],
									[
										12621,
										12626
									],
									[
										12904,
										12909
									],
									[
										12954,
										12959
									],
									[
										13260,
										13265
									],
									[
										13374,
										13379
									],
									[
										13405,
										13410
									],
									[
										13454,
										13459
									],
									[
										13491,
										13496
									],
									[
										13687,
										13692
									],
									[
										13814,
										13819
									],
									[
										14133,
										14138
									],
									[
										14175,
										14180
									],
									[
										14403,
										14408
									],
									[
										14418,
										14423
									],
									[
										14580,
										14585
									],
									[
										14998,
										15003
									],
									[
										15129,
										15134
									],
									[
										15223,
										15228
									],
									[
										15320,
										15325
									],
									[
										15586,
										15591
									],
									[
										15629,
										15634
									],
									[
										15731,
										15736
									],
									[
										15762,
										15767
									],
									[
										15844,
										15849
									],
									[
										16134,
										16139
									],
									[
										16226,
										16231
									],
									[
										16342,
										16347
									],
									[
										16517,
										16522
									],
									[
										16565,
										16570
									],
									[
										16710,
										16715
									],
									[
										17037,
										17042
									],
									[
										17108,
										17113
									],
									[
										17182,
										17187
									],
									[
										17236,
										17241
									],
									[
										17296,
										17301
									],
									[
										17406,
										17411
									],
									[
										17684,
										17689
									],
									[
										17697,
										17702
									],
									[
										17902,
										17907
									],
									[
										18023,
										18028
									],
									[
										18059,
										18064
									],
									[
										18070,
										18075
									],
									[
										18213,
										18218
									],
									[
										18228,
										18233
									],
									[
										18285,
										18290
									],
									[
										18296,
										18301
									],
									[
										18375,
										18380
									],
									[
										18398,
										18403
									],
									[
										18428,
										18433
									],
									[
										18461,
										18466
									],
									[
										18650,
										18655
									],
									[
										18716,
										18721
									],
									[
										18797,
										18802
									],
									[
										18812,
										18817
									],
									[
										18842,
										18847
									],
									[
										18879,
										18884
									],
									[
										18895,
										18900
									],
									[
										18923,
										18928
									],
									[
										18968,
										18973
									],
									[
										19014,
										19019
									],
									[
										19100,
										19105
									],
									[
										19196,
										19201
									],
									[
										19208,
										19213
									],
									[
										19317,
										19322
									],
									[
										19328,
										19333
									],
									[
										19358,
										19363
									],
									[
										19439,
										19444
									],
									[
										19543,
										19548
									],
									[
										19577,
										19582
									],
									[
										19779,
										19784
									],
									[
										19884,
										19889
									],
									[
										19899,
										19904
									],
									[
										19944,
										19949
									],
									[
										20004,
										20009
									],
									[
										20037,
										20042
									],
									[
										20197,
										20202
									],
									[
										20289,
										20294
									],
									[
										20327,
										20332
									],
									[
										20338,
										20343
									],
									[
										20409,
										20414
									],
									[
										20551,
										20556
									],
									[
										20716,
										20721
									],
									[
										20795,
										20800
									],
									[
										20918,
										20923
									],
									[
										20923,
										20928
									],
									[
										20965,
										20970
									],
									[
										21066,
										21071
									],
									[
										21071,
										21076
									],
									[
										21130,
										21135
									],
									[
										21191,
										21196
									],
									[
										21253,
										21258
									],
									[
										21390,
										21395
									],
									[
										21528,
										21533
									],
									[
										21564,
										21569
									],
									[
										21575,
										21580
									],
									[
										21749,
										21754
									],
									[
										21906,
										21911
									],
									[
										22010,
										22015
									],
									[
										22231,
										22236
									],
									[
										22303,
										22308
									],
									[
										22468,
										22473
									],
									[
										22574,
										22579
									],
									[
										22816,
										22821
									],
									[
										23006,
										23011
									],
									[
										23071,
										23076
									],
									[
										23149,
										23154
									],
									[
										23158,
										23163
									],
									[
										23349,
										23354
									],
									[
										23633,
										23638
									],
									[
										23761,
										23766
									],
									[
										23832,
										23837
									],
									[
										23925,
										23930
									],
									[
										24167,
										24172
									],
									[
										24257,
										24262
									],
									[
										24335,
										24340
									],
									[
										24478,
										24483
									],
									[
										24784,
										24789
									],
									[
										24842,
										24847
									],
									[
										25112,
										25117
									],
									[
										25152,
										25157
									],
									[
										25386,
										25391
									],
									[
										25572,
										25577
									],
									[
										25580,
										25585
									],
									[
										25774,
										25779
									],
									[
										25961,
										25966
									],
									[
										26103,
										26108
									],
									[
										26109,
										26114
									],
									[
										26302,
										26307
									],
									[
										26312,
										26317
									],
									[
										26437,
										26442
									],
									[
										26800,
										26805
									],
									[
										26806,
										26811
									],
									[
										27110,
										27115
									],
									[
										27278,
										27283
									],
									[
										27417,
										27422
									],
									[
										27530,
										27535
									],
									[
										27536,
										27541
									],
									[
										27777,
										27782
									],
									[
										27955,
										27960
									],
									[
										28197,
										28202
									],
									[
										28275,
										28280
									],
									[
										28351,
										28356
									],
									[
										28410,
										28415
									],
									[
										28462,
										28467
									],
									[
										28503,
										28508
									],
									[
										28660,
										28665
									],
									[
										28688,
										28693
									],
									[
										28716,
										28721
									],
									[
										28744,
										28749
									],
									[
										28832,
										28837
									],
									[
										28873,
										28878
									],
									[
										28917,
										28922
									],
									[
										28961,
										28966
									],
									[
										29005,
										29010
									],
									[
										29092,
										29097
									],
									[
										29138,
										29143
									],
									[
										29183,
										29188
									],
									[
										29227,
										29232
									],
									[
										29355,
										29360
									],
									[
										29401,
										29406
									],
									[
										29457,
										29462
									],
									[
										29471,
										29476
									],
									[
										29674,
										29679
									],
									[
										29694,
										29699
									],
									[
										29852,
										29857
									],
									[
										30058,
										30063
									],
									[
										30163,
										30168
									],
									[
										30218,
										30223
									],
									[
										30395,
										30400
									],
									[
										30523,
										30528
									],
									[
										30569,
										30574
									],
									[
										30759,
										30764
									],
									[
										30793,
										30798
									],
									[
										30901,
										30906
									],
									[
										30948,
										30953
									],
									[
										31179,
										31184
									],
									[
										31303,
										31308
									],
									[
										31352,
										31357
									],
									[
										31414,
										31419
									],
									[
										31614,
										31619
									],
									[
										31768,
										31773
									],
									[
										31899,
										31904
									],
									[
										32021,
										32026
									],
									[
										32110,
										32115
									],
									[
										32182,
										32187
									],
									[
										32203,
										32208
									],
									[
										32250,
										32255
									],
									[
										32426,
										32431
									],
									[
										32718,
										32723
									],
									[
										32865,
										32870
									],
									[
										33083,
										33088
									],
									[
										33283,
										33288
									],
									[
										33411,
										33416
									],
									[
										33419,
										33424
									],
									[
										33618,
										33623
									],
									[
										33823,
										33828
									],
									[
										33918,
										33923
									],
									[
										34181,
										34186
									],
									[
										34245,
										34250
									],
									[
										34462,
										34467
									],
									[
										34597,
										34602
									],
									[
										34617,
										34622
									],
									[
										34727,
										34732
									],
									[
										34893,
										34898
									],
									[
										34931,
										34936
									],
									[
										35145,
										35150
									],
									[
										35236,
										35241
									],
									[
										35245,
										35250
									],
									[
										35289,
										35294
									],
									[
										35301,
										35306
									],
									[
										35455,
										35460
									],
									[
										35674,
										35679
									],
									[
										35683,
										35688
									],
									[
										35731,
										35736
									],
									[
										35743,
										35748
									],
									[
										35775,
										35780
									],
									[
										36019,
										36024
									],
									[
										36150,
										36155
									],
									[
										36381,
										36386
									],
									[
										36493,
										36498
									],
									[
										36569,
										36574
									],
									[
										36696,
										36701
									],
									[
										36908,
										36913
									],
									[
										36935,
										36940
									],
									[
										36953,
										36958
									],
									[
										37040,
										37045
									],
									[
										37100,
										37105
									],
									[
										37204,
										37209
									],
									[
										37365,
										37370
									],
									[
										37548,
										37553
									],
									[
										37779,
										37784
									],
									[
										37874,
										37879
									],
									[
										37952,
										37957
									],
									[
										37992,
										37997
									],
									[
										38057,
										38062
									],
									[
										38092,
										38097
									],
									[
										38110,
										38115
									],
									[
										38158,
										38163
									],
									[
										38352,
										38357
									],
									[
										38424,
										38429
									],
									[
										38571,
										38576
									],
									[
										38644,
										38649
									],
									[
										38864,
										38869
									],
									[
										39079,
										39084
									],
									[
										39119,
										39124
									],
									[
										39184,
										39189
									],
									[
										39219,
										39224
									],
									[
										39237,
										39242
									],
									[
										39285,
										39290
									],
									[
										39474,
										39479
									],
									[
										39499,
										39504
									],
									[
										39675,
										39680
									],
									[
										39700,
										39705
									],
									[
										39886,
										39891
									],
									[
										39939,
										39944
									],
									[
										40093,
										40098
									],
									[
										40157,
										40162
									],
									[
										40245,
										40250
									],
									[
										40553,
										40558
									],
									[
										40820,
										40825
									],
									[
										41141,
										41146
									],
									[
										41321,
										41326
									],
									[
										41631,
										41636
									],
									[
										41672,
										41677
									],
									[
										41688,
										41693
									],
									[
										41726,
										41731
									],
									[
										41932,
										41937
									],
									[
										41952,
										41957
									],
									[
										41993,
										41998
									],
									[
										42011,
										42016
									],
									[
										42057,
										42062
									],
									[
										42079,
										42084
									],
									[
										42126,
										42131
									],
									[
										42149,
										42154
									],
									[
										42197,
										42202
									],
									[
										42221,
										42226
									],
									[
										42267,
										42272
									],
									[
										42290,
										42295
									],
									[
										42332,
										42337
									],
									[
										42350,
										42355
									],
									[
										42451,
										42456
									],
									[
										42672,
										42677
									],
									[
										42956,
										42961
									],
									[
										42997,
										43002
									],
									[
										43056,
										43061
									],
									[
										43101,
										43106
									],
									[
										43161,
										43166
									],
									[
										43207,
										43212
									],
									[
										43268,
										43273
									],
									[
										43308,
										43313
									],
									[
										43368,
										43373
									],
									[
										43415,
										43420
									],
									[
										43729,
										43734
									],
									[
										43745,
										43750
									],
									[
										43992,
										43997
									],
									[
										44231,
										44236
									],
									[
										44281,
										44286
									],
									[
										44499,
										44504
									],
									[
										44576,
										44581
									],
									[
										44653,
										44658
									],
									[
										44813,
										44818
									],
									[
										44889,
										44894
									],
									[
										44965,
										44970
									],
									[
										45204,
										45209
									],
									[
										45356,
										45361
									],
									[
										45406,
										45411
									],
									[
										45534,
										45539
									],
									[
										45548,
										45553
									],
									[
										45575,
										45580
									],
									[
										45656,
										45661
									],
									[
										45933,
										45938
									],
									[
										46001,
										46006
									],
									[
										46201,
										46206
									],
									[
										46427,
										46432
									],
									[
										46506,
										46511
									],
									[
										46707,
										46712
									],
									[
										46946,
										46951
									],
									[
										46976,
										46981
									],
									[
										47012,
										47017
									],
									[
										47086,
										47091
									],
									[
										47243,
										47248
									],
									[
										47275,
										47280
									],
									[
										47433,
										47438
									],
									[
										47438,
										47443
									],
									[
										47667,
										47672
									],
									[
										47818,
										47823
									],
									[
										47902,
										47907
									],
									[
										48103,
										48108
									],
									[
										48320,
										48325
									],
									[
										48555,
										48560
									],
									[
										48561,
										48566
									],
									[
										48779,
										48784
									],
									[
										49022,
										49027
									],
									[
										49298,
										49303
									],
									[
										49500,
										49505
									],
									[
										49506,
										49511
									],
									[
										49667,
										49672
									],
									[
										49833,
										49838
									],
									[
										49839,
										49844
									],
									[
										49991,
										49996
									],
									[
										49997,
										50002
									],
									[
										50144,
										50149
									],
									[
										50293,
										50298
									],
									[
										50485,
										50490
									],
									[
										50530,
										50535
									],
									[
										50578,
										50583
									],
									[
										50839,
										50844
									],
									[
										50845,
										50850
									],
									[
										51081,
										51086
									],
									[
										51236,
										51241
									],
									[
										51312,
										51317
									],
									[
										51405,
										51410
									],
									[
										51416,
										51421
									],
									[
										51473,
										51478
									],
									[
										51916,
										51921
									],
									[
										52072,
										52077
									],
									[
										52253,
										52258
									],
									[
										52451,
										52456
									],
									[
										52457,
										52462
									],
									[
										52570,
										52575
									],
									[
										52576,
										52581
									],
									[
										52706,
										52711
									],
									[
										52712,
										52717
									],
									[
										52914,
										52919
									],
									[
										52920,
										52925
									],
									[
										53154,
										53159
									],
									[
										53285,
										53290
									],
									[
										53379,
										53384
									],
									[
										53476,
										53481
									],
									[
										53732,
										53737
									],
									[
										53775,
										53780
									],
									[
										53877,
										53882
									],
									[
										53908,
										53913
									],
									[
										53990,
										53995
									],
									[
										54280,
										54285
									],
									[
										54372,
										54377
									],
									[
										54488,
										54493
									],
									[
										54663,
										54668
									],
									[
										54711,
										54716
									],
									[
										54856,
										54861
									],
									[
										55183,
										55188
									],
									[
										55254,
										55259
									],
									[
										55328,
										55333
									],
									[
										55382,
										55387
									],
									[
										55442,
										55447
									],
									[
										55552,
										55557
									],
									[
										55820,
										55825
									],
									[
										55833,
										55838
									],
									[
										56038,
										56043
									],
									[
										56159,
										56164
									],
									[
										56195,
										56200
									],
									[
										56206,
										56211
									],
									[
										56349,
										56354
									],
									[
										56364,
										56369
									],
									[
										56421,
										56426
									],
									[
										56432,
										56437
									],
									[
										56511,
										56516
									],
									[
										56534,
										56539
									],
									[
										56564,
										56569
									],
									[
										56597,
										56602
									],
									[
										56786,
										56791
									],
									[
										56852,
										56857
									],
									[
										56933,
										56938
									],
									[
										56948,
										56953
									],
									[
										56978,
										56983
									],
									[
										57015,
										57020
									],
									[
										57031,
										57036
									],
									[
										57059,
										57064
									],
									[
										57104,
										57109
									],
									[
										57150,
										57155
									],
									[
										57236,
										57241
									],
									[
										57332,
										57337
									],
									[
										57344,
										57349
									],
									[
										57453,
										57458
									],
									[
										57464,
										57469
									],
									[
										57494,
										57499
									],
									[
										57575,
										57580
									],
									[
										57679,
										57684
									],
									[
										57713,
										57718
									],
									[
										57915,
										57920
									],
									[
										58020,
										58025
									],
									[
										58035,
										58040
									],
									[
										58080,
										58085
									],
									[
										58140,
										58145
									],
									[
										58173,
										58178
									],
									[
										58333,
										58338
									],
									[
										58425,
										58430
									],
									[
										58463,
										58468
									],
									[
										58474,
										58479
									],
									[
										58545,
										58550
									],
									[
										58687,
										58692
									],
									[
										58852,
										58857
									],
									[
										58931,
										58936
									],
									[
										59054,
										59059
									],
									[
										59059,
										59064
									],
									[
										59101,
										59106
									],
									[
										59202,
										59207
									],
									[
										59207,
										59212
									],
									[
										59266,
										59271
									],
									[
										59327,
										59332
									],
									[
										59389,
										59394
									],
									[
										59526,
										59531
									],
									[
										59664,
										59669
									],
									[
										59700,
										59705
									],
									[
										59711,
										59716
									],
									[
										59885,
										59890
									],
									[
										60042,
										60047
									],
									[
										60146,
										60151
									],
									[
										60367,
										60372
									],
									[
										60439,
										60444
									],
									[
										60604,
										60609
									],
									[
										60710,
										60715
									],
									[
										60952,
										60957
									],
									[
										61142,
										61147
									],
									[
										61207,
										61212
									],
									[
										61285,
										61290
									],
									[
										61294,
										61299
									],
									[
										61485,
										61490
									],
									[
										61769,
										61774
									],
									[
										61897,
										61902
									],
									[
										61968,
										61973
									],
									[
										62061,
										62066
									],
									[
										62303,
										62308
									],
									[
										62393,
										62398
									],
									[
										62471,
										62476
									],
									[
										62614,
										62619
									],
									[
										62910,
										62915
									],
									[
										62968,
										62973
									],
									[
										63238,
										63243
									],
									[
										63278,
										63283
									],
									[
										63512,
										63517
									],
									[
										63698,
										63703
									],
									[
										63706,
										63711
									],
									[
										63900,
										63905
									],
									[
										64087,
										64092
									],
									[
										64229,
										64234
									],
									[
										64235,
										64240
									],
									[
										64428,
										64433
									],
									[
										64438,
										64443
									],
									[
										64563,
										64568
									],
									[
										64926,
										64931
									],
									[
										64932,
										64937
									],
									[
										65236,
										65241
									],
									[
										65404,
										65409
									],
									[
										65543,
										65548
									],
									[
										65656,
										65661
									],
									[
										65662,
										65667
									],
									[
										65903,
										65908
									],
									[
										66081,
										66086
									],
									[
										66313,
										66318
									],
									[
										66391,
										66396
									],
									[
										66467,
										66472
									],
									[
										66526,
										66531
									],
									[
										66578,
										66583
									],
									[
										66619,
										66624
									],
									[
										66776,
										66781
									],
									[
										66804,
										66809
									],
									[
										66832,
										66837
									],
									[
										66860,
										66865
									],
									[
										66948,
										66953
									],
									[
										66989,
										66994
									],
									[
										67033,
										67038
									],
									[
										67077,
										67082
									],
									[
										67121,
										67126
									],
									[
										67208,
										67213
									],
									[
										67254,
										67259
									],
									[
										67299,
										67304
									],
									[
										67343,
										67348
									],
									[
										67471,
										67476
									],
									[
										67517,
										67522
									],
									[
										67573,
										67578
									],
									[
										67587,
										67592
									],
									[
										67790,
										67795
									],
									[
										67810,
										67815
									],
									[
										67968,
										67973
									],
									[
										68164,
										68169
									],
									[
										68269,
										68274
									],
									[
										68324,
										68329
									],
									[
										68501,
										68506
									],
									[
										68629,
										68634
									],
									[
										68675,
										68680
									],
									[
										68855,
										68860
									],
									[
										68889,
										68894
									],
									[
										68997,
										69002
									],
									[
										69044,
										69049
									],
									[
										69275,
										69280
									],
									[
										69399,
										69404
									],
									[
										69448,
										69453
									],
									[
										69510,
										69515
									],
									[
										69710,
										69715
									],
									[
										69864,
										69869
									],
									[
										69995,
										70000
									],
									[
										70117,
										70122
									],
									[
										70206,
										70211
									],
									[
										70278,
										70283
									],
									[
										70299,
										70304
									],
									[
										70346,
										70351
									],
									[
										70522,
										70527
									],
									[
										70804,
										70809
									],
									[
										70951,
										70956
									],
									[
										71169,
										71174
									],
									[
										71369,
										71374
									],
									[
										71497,
										71502
									],
									[
										71505,
										71510
									],
									[
										71704,
										71709
									],
									[
										71909,
										71914
									],
									[
										72004,
										72009
									],
									[
										72257,
										72262
									],
									[
										72321,
										72326
									],
									[
										72538,
										72543
									],
									[
										72673,
										72678
									],
									[
										72693,
										72698
									],
									[
										72803,
										72808
									],
									[
										72969,
										72974
									],
									[
										73007,
										73012
									],
									[
										73221,
										73226
									],
									[
										73312,
										73317
									],
									[
										73321,
										73326
									],
									[
										73365,
										73370
									],
									[
										73377,
										73382
									],
									[
										73531,
										73536
									],
									[
										73750,
										73755
									],
									[
										73759,
										73764
									],
									[
										73807,
										73812
									],
									[
										73819,
										73824
									],
									[
										73851,
										73856
									],
									[
										74095,
										74100
									],
									[
										74226,
										74231
									],
									[
										74457,
										74462
									],
									[
										74569,
										74574
									],
									[
										74645,
										74650
									],
									[
										74772,
										74777
									],
									[
										74984,
										74989
									],
									[
										75011,
										75016
									],
									[
										75029,
										75034
									],
									[
										75116,
										75121
									],
									[
										75176,
										75181
									],
									[
										75280,
										75285
									],
									[
										75441,
										75446
									],
									[
										75624,
										75629
									],
									[
										75855,
										75860
									],
									[
										75950,
										75955
									],
									[
										76028,
										76033
									],
									[
										76068,
										76073
									],
									[
										76133,
										76138
									],
									[
										76168,
										76173
									],
									[
										76186,
										76191
									],
									[
										76234,
										76239
									],
									[
										76428,
										76433
									],
									[
										76500,
										76505
									],
									[
										76647,
										76652
									],
									[
										76720,
										76725
									],
									[
										76940,
										76945
									],
									[
										77155,
										77160
									],
									[
										77195,
										77200
									],
									[
										77260,
										77265
									],
									[
										77295,
										77300
									],
									[
										77313,
										77318
									],
									[
										77361,
										77366
									],
									[
										77550,
										77555
									],
									[
										77575,
										77580
									],
									[
										77751,
										77756
									],
									[
										77776,
										77781
									],
									[
										77962,
										77967
									],
									[
										78015,
										78020
									],
									[
										78169,
										78174
									],
									[
										78233,
										78238
									],
									[
										78321,
										78326
									],
									[
										78619,
										78624
									],
									[
										78886,
										78891
									],
									[
										79197,
										79202
									],
									[
										79377,
										79382
									],
									[
										79677,
										79682
									],
									[
										79718,
										79723
									],
									[
										79734,
										79739
									],
									[
										79772,
										79777
									],
									[
										79978,
										79983
									],
									[
										79998,
										80003
									],
									[
										80039,
										80044
									],
									[
										80057,
										80062
									],
									[
										80103,
										80108
									],
									[
										80125,
										80130
									],
									[
										80172,
										80177
									],
									[
										80195,
										80200
									],
									[
										80243,
										80248
									],
									[
										80267,
										80272
									],
									[
										80313,
										80318
									],
									[
										80336,
										80341
									],
									[
										80378,
										80383
									],
									[
										80396,
										80401
									],
									[
										80497,
										80502
									],
									[
										80718,
										80723
									],
									[
										81002,
										81007
									],
									[
										81043,
										81048
									],
									[
										81102,
										81107
									],
									[
										81147,
										81152
									],
									[
										81207,
										81212
									],
									[
										81253,
										81258
									],
									[
										81314,
										81319
									],
									[
										81354,
										81359
									],
									[
										81414,
										81419
									],
									[
										81461,
										81466
									],
									[
										81775,
										81780
									],
									[
										81791,
										81796
									],
									[
										82038,
										82043
									],
									[
										82267,
										82272
									],
									[
										82317,
										82322
									],
									[
										82535,
										82540
									],
									[
										82612,
										82617
									],
									[
										82689,
										82694
									],
									[
										82849,
										82854
									],
									[
										82925,
										82930
									],
									[
										83001,
										83006
									],
									[
										83230,
										83235
									],
									[
										83382,
										83387
									],
									[
										83432,
										83437
									],
									[
										83560,
										83565
									],
									[
										83574,
										83579
									],
									[
										83601,
										83606
									],
									[
										83682,
										83687
									],
									[
										83959,
										83964
									],
									[
										84027,
										84032
									],
									[
										84227,
										84232
									],
									[
										84453,
										84458
									],
									[
										84532,
										84537
									],
									[
										84723,
										84728
									],
									[
										84962,
										84967
									],
									[
										84992,
										84997
									],
									[
										85028,
										85033
									],
									[
										85102,
										85107
									],
									[
										85259,
										85264
									],
									[
										85291,
										85296
									],
									[
										85449,
										85454
									],
									[
										85454,
										85459
									],
									[
										85682,
										85687
									],
									[
										85697,
										85702
									],
									[
										85843,
										85848
									],
									[
										85949,
										85954
									],
									[
										85957,
										85962
									],
									[
										85993,
										85998
									],
									[
										85998,
										86003
									],
									[
										86108,
										86113
									],
									[
										86123,
										86128
									],
									[
										86193,
										86198
									],
									[
										86198,
										86203
									],
									[
										86288,
										86293
									],
									[
										86474,
										86479
									],
									[
										86523,
										86528
									],
									[
										86693,
										86698
									],
									[
										86847,
										86852
									],
									[
										87098,
										87103
									],
									[
										87138,
										87143
									],
									[
										87238,
										87243
									],
									[
										87417,
										87422
									],
									[
										87461,
										87466
									],
									[
										87573,
										87578
									],
									[
										87619,
										87624
									],
									[
										87650,
										87655
									],
									[
										87684,
										87689
									],
									[
										87740,
										87745
									],
									[
										87822,
										87827
									],
									[
										87829,
										87834
									],
									[
										87894,
										87899
									],
									[
										87901,
										87906
									],
									[
										87908,
										87913
									],
									[
										87978,
										87983
									],
									[
										87993,
										87998
									],
									[
										88068,
										88073
									],
									[
										88081,
										88086
									],
									[
										88144,
										88149
									],
									[
										88157,
										88162
									],
									[
										88186,
										88191
									],
									[
										88267,
										88272
									],
									[
										88276,
										88281
									],
									[
										88320,
										88325
									],
									[
										88364,
										88369
									],
									[
										88373,
										88378
									],
									[
										88417,
										88422
									],
									[
										88515,
										88520
									],
									[
										88585,
										88590
									],
									[
										88623,
										88628
									],
									[
										88693,
										88698
									],
									[
										88752,
										88757
									],
									[
										88761,
										88766
									],
									[
										88805,
										88810
									],
									[
										88853,
										88858
									],
									[
										88918,
										88923
									],
									[
										88952,
										88957
									],
									[
										88971,
										88976
									],
									[
										89084,
										89089
									],
									[
										89195,
										89200
									],
									[
										89227,
										89232
									],
									[
										89393,
										89398
									],
									[
										89402,
										89407
									],
									[
										89574,
										89579
									],
									[
										89691,
										89696
									],
									[
										89756,
										89761
									],
									[
										89771,
										89776
									],
									[
										89840,
										89845
									],
									[
										90080,
										90085
									],
									[
										90216,
										90221
									],
									[
										90553,
										90558
									],
									[
										90649,
										90654
									],
									[
										90735,
										90740
									],
									[
										90744,
										90749
									],
									[
										90752,
										90757
									],
									[
										90973,
										90978
									],
									[
										91124,
										91129
									],
									[
										91208,
										91213
									],
									[
										91409,
										91414
									],
									[
										91626,
										91631
									],
									[
										91861,
										91866
									],
									[
										91867,
										91872
									],
									[
										92085,
										92090
									],
									[
										92328,
										92333
									],
									[
										92604,
										92609
									],
									[
										92806,
										92811
									],
									[
										92812,
										92817
									],
									[
										92973,
										92978
									],
									[
										93139,
										93144
									],
									[
										93145,
										93150
									],
									[
										93297,
										93302
									],
									[
										93303,
										93308
									],
									[
										93450,
										93455
									],
									[
										93599,
										93604
									],
									[
										93791,
										93796
									],
									[
										93836,
										93841
									],
									[
										93884,
										93889
									],
									[
										94145,
										94150
									],
									[
										94151,
										94156
									],
									[
										94375,
										94380
									],
									[
										94530,
										94535
									],
									[
										94606,
										94611
									],
									[
										94699,
										94704
									],
									[
										94710,
										94715
									],
									[
										94767,
										94772
									],
									[
										95198,
										95203
									],
									[
										95354,
										95359
									],
									[
										95535,
										95540
									],
									[
										95733,
										95738
									],
									[
										95739,
										95744
									],
									[
										95852,
										95857
									],
									[
										95858,
										95863
									],
									[
										95988,
										95993
									],
									[
										95994,
										95999
									],
									[
										96196,
										96201
									],
									[
										96202,
										96207
									],
									[
										96391,
										96396
									],
									[
										96442,
										96447
									],
									[
										96449,
										96454
									],
									[
										96676,
										96681
									],
									[
										97034,
										97039
									],
									[
										97081,
										97086
									],
									[
										97210,
										97215
									],
									[
										97224,
										97229
									],
									[
										97382,
										97387
									],
									[
										97640,
										97647
									],
									[
										97873,
										97880
									],
									[
										98091,
										98098
									],
									[
										98402,
										98409
									],
									[
										98676,
										98683
									],
									[
										98909,
										98916
									],
									[
										99256,
										99263
									],
									[
										99535,
										99542
									],
									[
										99848,
										99855
									],
									[
										100223,
										100230
									],
									[
										100550,
										100557
									],
									[
										100817,
										100824
									],
									[
										100845,
										100852
									],
									[
										100873,
										100880
									],
									[
										100901,
										100908
									],
									[
										101105,
										101112
									],
									[
										101207,
										101214
									],
									[
										101473,
										101480
									],
									[
										101704,
										101711
									],
									[
										101935,
										101942
									],
									[
										102087,
										102094
									],
									[
										102404,
										102411
									],
									[
										102535,
										102542
									],
									[
										102744,
										102751
									],
									[
										103073,
										103080
									],
									[
										103168,
										103175
									],
									[
										103465,
										103472
									],
									[
										103729,
										103736
									],
									[
										103790,
										103797
									],
									[
										103854,
										103861
									],
									[
										103923,
										103930
									],
									[
										103994,
										104001
									],
									[
										104064,
										104071
									],
									[
										104129,
										104136
									],
									[
										104320,
										104327
									],
									[
										104637,
										104644
									],
									[
										104894,
										104901
									],
									[
										104922,
										104929
									],
									[
										104950,
										104957
									],
									[
										104978,
										104985
									],
									[
										105182,
										105189
									],
									[
										105284,
										105291
									],
									[
										105540,
										105547
									],
									[
										105761,
										105768
									],
									[
										105992,
										105999
									],
									[
										106144,
										106151
									],
									[
										106451,
										106458
									],
									[
										106582,
										106589
									],
									[
										106791,
										106798
									],
									[
										107120,
										107127
									],
									[
										107215,
										107222
									],
									[
										107512,
										107519
									],
									[
										107766,
										107773
									],
									[
										107827,
										107834
									],
									[
										107891,
										107898
									],
									[
										107960,
										107967
									],
									[
										108031,
										108038
									],
									[
										108101,
										108108
									],
									[
										108166,
										108173
									],
									[
										108429,
										108436
									],
									[
										108501,
										108508
									],
									[
										108585,
										108592
									],
									[
										108836,
										108843
									],
									[
										109165,
										109172
									],
									[
										109404,
										109411
									],
									[
										109568,
										109575
									],
									[
										109842,
										109851
									],
									[
										110157,
										110166
									],
									[
										110542,
										110551
									],
									[
										110845,
										110854
									],
									[
										110915,
										110924
									],
									[
										110942,
										110951
									],
									[
										111191,
										111200
									],
									[
										111263,
										111272
									],
									[
										111359,
										111368
									],
									[
										111384,
										111393
									],
									[
										111641,
										111650
									],
									[
										111987,
										111996
									],
									[
										112244,
										112253
									],
									[
										112489,
										112498
									],
									[
										112539,
										112548
									],
									[
										112845,
										112854
									],
									[
										113133,
										113142
									],
									[
										113528,
										113534
									],
									[
										114090,
										114096
									],
									[
										114289,
										114295
									],
									[
										114415,
										114421
									],
									[
										114751,
										114757
									],
									[
										115035,
										115041
									],
									[
										115253,
										115259
									],
									[
										115416,
										115422
									],
									[
										115580,
										115586
									],
									[
										115781,
										115787
									],
									[
										116091,
										116097
									],
									[
										116326,
										116332
									],
									[
										116563,
										116569
									],
									[
										116753,
										116759
									],
									[
										116929,
										116935
									],
									[
										117035,
										117041
									],
									[
										117122,
										117128
									],
									[
										117240,
										117246
									],
									[
										117431,
										117437
									],
									[
										117574,
										117580
									],
									[
										117800,
										117806
									],
									[
										118072,
										118078
									],
									[
										118235,
										118241
									],
									[
										118447,
										118453
									],
									[
										118708,
										118714
									],
									[
										118753,
										118759
									],
									[
										118798,
										118804
									],
									[
										118898,
										118904
									],
									[
										119090,
										119096
									],
									[
										119224,
										119230
									],
									[
										119293,
										119299
									],
									[
										119362,
										119368
									],
									[
										119431,
										119437
									],
									[
										119498,
										119504
									],
									[
										119676,
										119682
									],
									[
										119948,
										119954
									],
									[
										119992,
										119998
									],
									[
										120037,
										120043
									],
									[
										120215,
										120221
									],
									[
										120449,
										120455
									],
									[
										120509,
										120515
									],
									[
										120571,
										120577
									],
									[
										120636,
										120642
									],
									[
										120884,
										120890
									],
									[
										121059,
										121065
									],
									[
										121318,
										121324
									],
									[
										121613,
										121619
									],
									[
										121642,
										121648
									],
									[
										121671,
										121677
									],
									[
										121914,
										121920
									],
									[
										121973,
										121979
									],
									[
										122014,
										122020
									],
									[
										122460,
										122466
									],
									[
										122584,
										122590
									],
									[
										122767,
										122773
									],
									[
										122878,
										122884
									],
									[
										123050,
										123056
									],
									[
										123203,
										123209
									],
									[
										123509,
										123515
									],
									[
										123604,
										123610
									],
									[
										123695,
										123701
									],
									[
										123749,
										123755
									],
									[
										123875,
										123881
									],
									[
										124050,
										124056
									],
									[
										124147,
										124153
									],
									[
										124237,
										124243
									],
									[
										124335,
										124341
									],
									[
										124583,
										124589
									],
									[
										124888,
										124894
									],
									[
										124943,
										124949
									],
									[
										124980,
										124986
									],
									[
										125406,
										125412
									],
									[
										125547,
										125553
									],
									[
										125693,
										125699
									],
									[
										125782,
										125788
									],
									[
										125864,
										125870
									],
									[
										125954,
										125960
									],
									[
										126182,
										126188
									],
									[
										126363,
										126369
									],
									[
										126622,
										126628
									],
									[
										126800,
										126806
									],
									[
										127019,
										127025
									],
									[
										127169,
										127175
									],
									[
										127268,
										127274
									],
									[
										127375,
										127381
									],
									[
										127521,
										127527
									],
									[
										127626,
										127632
									],
									[
										127827,
										127833
									],
									[
										128016,
										128022
									],
									[
										128154,
										128160
									],
									[
										128345,
										128351
									],
									[
										128453,
										128459
									],
									[
										128686,
										128692
									],
									[
										128799,
										128805
									],
									[
										129112,
										129118
									],
									[
										129165,
										129171
									],
									[
										129218,
										129224
									],
									[
										129416,
										129422
									],
									[
										129653,
										129659
									],
									[
										129960,
										129966
									],
									[
										130237,
										130243
									],
									[
										130539,
										130545
									],
									[
										130940,
										130946
									],
									[
										131327,
										131333
									],
									[
										131605,
										131611
									],
									[
										131786,
										131792
									],
									[
										132045,
										132051
									],
									[
										132187,
										132193
									],
									[
										132245,
										132251
									],
									[
										132388,
										132394
									],
									[
										132424,
										132430
									],
									[
										132602,
										132608
									],
									[
										132767,
										132773
									],
									[
										132899,
										132905
									],
									[
										132949,
										132955
									],
									[
										133003,
										133009
									],
									[
										133190,
										133196
									],
									[
										133426,
										133432
									],
									[
										133542,
										133548
									],
									[
										133734,
										133740
									],
									[
										134003,
										134009
									],
									[
										134249,
										134255
									],
									[
										134350,
										134356
									],
									[
										134438,
										134444
									],
									[
										134686,
										134692
									],
									[
										134927,
										134933
									],
									[
										135068,
										135074
									],
									[
										135272,
										135278
									],
									[
										135341,
										135347
									],
									[
										135420,
										135426
									],
									[
										135672,
										135678
									],
									[
										135949,
										135955
									],
									[
										136163,
										136169
									],
									[
										136403,
										136409
									],
									[
										136533,
										136539
									],
									[
										136656,
										136662
									],
									[
										136961,
										136967
									],
									[
										137088,
										137094
									],
									[
										137307,
										137313
									],
									[
										137520,
										137526
									],
									[
										137774,
										137780
									],
									[
										137911,
										137917
									],
									[
										138175,
										138181
									],
									[
										138413,
										138419
									],
									[
										138708,
										138714
									],
									[
										138900,
										138906
									],
									[
										139081,
										139087
									],
									[
										139273,
										139279
									],
									[
										139503,
										139509
									],
									[
										139875,
										139881
									],
									[
										140437,
										140443
									],
									[
										140636,
										140642
									],
									[
										140762,
										140768
									],
									[
										141098,
										141104
									],
									[
										141382,
										141388
									],
									[
										141600,
										141606
									],
									[
										141763,
										141769
									],
									[
										141927,
										141933
									],
									[
										142128,
										142134
									],
									[
										142438,
										142444
									],
									[
										142673,
										142679
									],
									[
										142910,
										142916
									],
									[
										143100,
										143106
									],
									[
										143276,
										143282
									],
									[
										143382,
										143388
									],
									[
										143469,
										143475
									],
									[
										143587,
										143593
									],
									[
										143778,
										143784
									],
									[
										143921,
										143927
									],
									[
										144147,
										144153
									],
									[
										144419,
										144425
									],
									[
										144582,
										144588
									],
									[
										144794,
										144800
									],
									[
										145055,
										145061
									],
									[
										145100,
										145106
									],
									[
										145145,
										145151
									],
									[
										145245,
										145251
									],
									[
										145437,
										145443
									],
									[
										145571,
										145577
									],
									[
										145640,
										145646
									],
									[
										145709,
										145715
									],
									[
										145778,
										145784
									],
									[
										145845,
										145851
									],
									[
										146023,
										146029
									],
									[
										146295,
										146301
									],
									[
										146339,
										146345
									],
									[
										146384,
										146390
									],
									[
										146562,
										146568
									],
									[
										146796,
										146802
									],
									[
										146856,
										146862
									],
									[
										146918,
										146924
									],
									[
										146983,
										146989
									],
									[
										147231,
										147237
									],
									[
										147406,
										147412
									],
									[
										147665,
										147671
									],
									[
										147960,
										147966
									],
									[
										147989,
										147995
									],
									[
										148018,
										148024
									],
									[
										148261,
										148267
									],
									[
										148320,
										148326
									],
									[
										148361,
										148367
									],
									[
										148807,
										148813
									],
									[
										148931,
										148937
									],
									[
										149114,
										149120
									],
									[
										149225,
										149231
									],
									[
										149397,
										149403
									],
									[
										149550,
										149556
									],
									[
										149856,
										149862
									],
									[
										149951,
										149957
									],
									[
										150042,
										150048
									],
									[
										150096,
										150102
									],
									[
										150222,
										150228
									],
									[
										150397,
										150403
									],
									[
										150494,
										150500
									],
									[
										150584,
										150590
									],
									[
										150682,
										150688
									],
									[
										150930,
										150936
									],
									[
										151235,
										151241
									],
									[
										151290,
										151296
									],
									[
										151327,
										151333
									],
									[
										151753,
										151759
									],
									[
										151894,
										151900
									],
									[
										152040,
										152046
									],
									[
										152129,
										152135
									],
									[
										152211,
										152217
									],
									[
										152301,
										152307
									],
									[
										152529,
										152535
									],
									[
										152710,
										152716
									],
									[
										152969,
										152975
									],
									[
										153147,
										153153
									],
									[
										153366,
										153372
									],
									[
										153516,
										153522
									],
									[
										153615,
										153621
									],
									[
										153722,
										153728
									],
									[
										153868,
										153874
									],
									[
										153973,
										153979
									],
									[
										154174,
										154180
									],
									[
										154363,
										154369
									],
									[
										154501,
										154507
									],
									[
										154692,
										154698
									],
									[
										154800,
										154806
									],
									[
										155033,
										155039
									],
									[
										155146,
										155152
									],
									[
										155459,
										155465
									],
									[
										155512,
										155518
									],
									[
										155565,
										155571
									],
									[
										155763,
										155769
									],
									[
										156000,
										156006
									],
									[
										156307,
										156313
									],
									[
										156584,
										156590
									],
									[
										156886,
										156892
									],
									[
										157287,
										157293
									],
									[
										157674,
										157680
									],
									[
										157952,
										157958
									],
									[
										158133,
										158139
									],
									[
										158392,
										158398
									],
									[
										158534,
										158540
									],
									[
										158592,
										158598
									],
									[
										158735,
										158741
									],
									[
										158771,
										158777
									],
									[
										158949,
										158955
									],
									[
										159114,
										159120
									],
									[
										159246,
										159252
									],
									[
										159296,
										159302
									],
									[
										159350,
										159356
									],
									[
										159537,
										159543
									],
									[
										159773,
										159779
									],
									[
										159889,
										159895
									],
									[
										160081,
										160087
									],
									[
										160350,
										160356
									],
									[
										160596,
										160602
									],
									[
										160697,
										160703
									],
									[
										160785,
										160791
									],
									[
										161033,
										161039
									],
									[
										161274,
										161280
									],
									[
										161415,
										161421
									],
									[
										161619,
										161625
									],
									[
										161688,
										161694
									],
									[
										161767,
										161773
									],
									[
										162019,
										162025
									],
									[
										162296,
										162302
									],
									[
										162510,
										162516
									],
									[
										162750,
										162756
									],
									[
										162880,
										162886
									],
									[
										163003,
										163009
									],
									[
										163308,
										163314
									],
									[
										163435,
										163441
									],
									[
										163654,
										163660
									],
									[
										163867,
										163873
									],
									[
										164121,
										164127
									],
									[
										164258,
										164264
									],
									[
										164522,
										164528
									],
									[
										164760,
										164766
									],
									[
										165055,
										165061
									],
									[
										165247,
										165253
									],
									[
										165428,
										165434
									],
									[
										165620,
										165626
									],
									[
										165850,
										165856
									],
									[
										166186,
										166190
									],
									[
										166481,
										166485
									],
									[
										166754,
										166758
									],
									[
										166904,
										166908
									],
									[
										167218,
										167222
									],
									[
										167559,
										167563
									],
									[
										167839,
										167843
									],
									[
										168130,
										168134
									],
									[
										168393,
										168397
									],
									[
										168543,
										168547
									],
									[
										168847,
										168851
									],
									[
										169178,
										169182
									],
									[
										169458,
										169462
									],
									[
										169738,
										169742
									],
									[
										169967,
										169971
									],
									[
										170044,
										170048
									],
									[
										170214,
										170218
									]
								],
								"scope": ""
							}
						},
						"selection":
						[
							[
								166189,
								166189
							]
						],
						"settings":
						{
							"detect_indentation": false,
							"output_tag": 17,
							"result_base_dir": "",
							"result_file_regex": "^([A-Za-z\\\\/<].*):$",
							"result_line_regex": "^ +([0-9]+):",
							"scroll_past_end": true,
							"syntax": "Packages/Default/Find Results.hidden-tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 64035.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "showscraper.py",
					"settings":
					{
						"buffer_size": 8396,
						"regions":
						{
						},
						"selection":
						[
							[
								4526,
								4526
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1356.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "grammar.py",
					"settings":
					{
						"buffer_size": 845,
						"regions":
						{
						},
						"selection":
						[
							[
								355,
								355
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "parserunner.py",
					"settings":
					{
						"buffer_size": 2211,
						"regions":
						{
						},
						"selection":
						[
							[
								2211,
								2211
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 102.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "ringcleaner.py",
					"settings":
					{
						"buffer_size": 3811,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "cleaned/COUL1.pdf2txt.txt",
					"settings":
					{
						"buffer_size": 0,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 7,
					"file": "cleaned/GRMS1.pdf2txt.txt",
					"settings":
					{
						"buffer_size": 50580,
						"regions":
						{
						},
						"selection":
						[
							[
								19103,
								19109
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 22807.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 8,
					"file": "model/show.py",
					"settings":
					{
						"buffer_size": 4912,
						"regions":
						{
						},
						"selection":
						[
							[
								1819,
								1819
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 539.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 9,
					"file": "util.py",
					"settings":
					{
						"buffer_size": 2136,
						"regions":
						{
						},
						"selection":
						[
							[
								25,
								25
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 10,
					"file": "driver.py",
					"settings":
					{
						"buffer_size": 131476,
						"regions":
						{
						},
						"selection":
						[
							[
								130678,
								130678
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1606.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 11,
					"file": "cleaned/BRAZ1.pdfbox.txt",
					"settings":
					{
						"buffer_size": 19820,
						"regions":
						{
						},
						"selection":
						[
							[
								12151,
								12151
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 4680.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 12,
					"file": "config.py",
					"settings":
					{
						"buffer_size": 1164,
						"regions":
						{
						},
						"selection":
						[
							[
								245,
								245
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 13,
					"file": "cleaned/COUL1.pdfbox.txt",
					"settings":
					{
						"buffer_size": 22463,
						"regions":
						{
						},
						"selection":
						[
							[
								10136,
								10136
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 3109.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 14,
					"file": "parsed/COUL1.pdfbox.txt",
					"settings":
					{
						"buffer_size": 0,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 6653.0,
						"zoom_level": 1.0
					},
					"type": "text"
				},
				{
					"buffer": 15,
					"file": "/C/Users/Taylor/Documents/GitHub/dogshow/grammar/ANTLR/bin/README.txt",
					"settings":
					{
						"buffer_size": 106,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 0.0
	},
	"input":
	{
		"height": 31.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.exec":
	{
		"height": 25.0
	},
	"replace":
	{
		"height": 65.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 500.0,
		"selected_items":
		[
		],
		"width": 380.0
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 225.0,
	"status_bar_visible": true
}
